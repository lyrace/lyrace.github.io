<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>LeetCode on My Blog</title>
    <link>https://lyrace.github.io/categories/leetcode/</link>
    <description>Recent content in LeetCode on My Blog</description>
    <image>
      <url>https://lyrace.github.io/papermod-cover.png</url>
      <link>https://lyrace.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 13 Feb 2022 12:26:32 +0800</lastBuildDate><atom:link href="https://lyrace.github.io/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>【LeetCode】69.x的平方根(未完)</title>
      <link>https://lyrace.github.io/post/leetcode69/</link>
      <pubDate>Sun, 13 Feb 2022 12:26:32 +0800</pubDate>
      
      <guid>https://lyrace.github.io/post/leetcode69/</guid>
      <description>69.x的平方根 题目链接
给你一个非负整数 x ，计算并返回 x 的算术平方根 。
由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
示例1：
输入：x = 4 输出：2 示例2：
输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示：
 0 &amp;lt;= x &amp;lt;= 2 ^31^ - 1  二分查找 class Solution { public int mySqrt(int x) { int left = 1; int right = x; int mid = x / 2; while(left &amp;lt;= right){ if(mid * mid == x){ // 算数平方根是整数的  return mid; } // 乘法超出int范围-&amp;gt;long  else if((long)mid * mid &amp;lt; x){ // mid * mid 比 x 小  if((long)(mid + 1) * (mid + 1) &amp;gt; x){ // mid * mid 比 x 小且(mid + 1) * (mid + 1)比 x 大  return mid; }else if((long)(mid + 1) * (mid + 1) == x) { // mid * mid 比 x 小且(mid + 1) * (mid + 1)等于x  return mid + 1; }else{ // 否则查找范围在右半边  left = mid + 1; } }else if((long)mid * mid &amp;gt; x){ // 查找范围在左半边  right = mid - 1; } mid = left + (right - left) / 2; } return 0; } }  官方题解  class Solution { public int mySqrt(int x) { int l = 0, r = x, ans = -1; while (l &amp;lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid &amp;lt;= x) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } } 牛顿迭代法 </description>
    </item>
    
    <item>
      <title>【LeetCode】34. 在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://lyrace.github.io/post/leetcode34/</link>
      <pubDate>Sun, 30 Jan 2022 17:08:25 +0800</pubDate>
      
      <guid>https://lyrace.github.io/post/leetcode34/</guid>
      <description>34.在排序数组中查找元素的第一个和最后一个位置 题目链接
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
如果数组中不存在目标值 target，返回 [-1, -1]。
示例1：
输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例2：
输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例3：
输入：nums = [], target = 0 输出：[-1,-1] 提示：
  0 &amp;lt;= nums.length &amp;lt;= 105
  -109 &amp;lt;= nums[i] &amp;lt;= 109
  nums 是一个非递减数组
  -109 &amp;lt;= target &amp;lt;= 109
  二分法 class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.</description>
    </item>
    
    <item>
      <title>【LeetCode】35.搜索插入位置</title>
      <link>https://lyrace.github.io/post/leetcode35/</link>
      <pubDate>Sun, 30 Jan 2022 08:08:25 +0800</pubDate>
      
      <guid>https://lyrace.github.io/post/leetcode35/</guid>
      <description>35.搜索插入位置 题目链接
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
请必须使用时间复杂度为O(log n)的算法。
示例1：
输入: nums = [1,3,5,6], target = 5 输出: 2 示例2：
输入: nums = [1,3,5,6], target = 2 输出: 1 示例3：
输入: nums = [1,3,5,6], target = 7 输出: 4 示例4：
输入: nums = [1,3,5,6], target = 0 输出: 0 示例5：
输入: nums = [1], target = 0 输出: 0 提示：
 1 &amp;lt;= nums.length &amp;lt;= 104 -104 &amp;lt;= nums[i] &amp;lt;= 104 nums 为无重复元素的升序排列数组 -104 &amp;lt;= target &amp;lt;= 104  二分法 class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.</description>
    </item>
    
    <item>
      <title>【LeetCode】704.二分查找</title>
      <link>https://lyrace.github.io/post/leetcode704/</link>
      <pubDate>Sun, 30 Jan 2022 08:08:25 +0800</pubDate>
      
      <guid>https://lyrace.github.io/post/leetcode704/</guid>
      <description>704.二分查找 题目链接
给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
示例1：
输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例2：
输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：
 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。  二分查找 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.</description>
    </item>
    
    <item>
      <title>【LeetCode】4.寻找两个正序数组的中位数（未完）</title>
      <link>https://lyrace.github.io/post/leetcode4/</link>
      <pubDate>Sat, 29 Jan 2022 18:49:13 +0800</pubDate>
      
      <guid>https://lyrace.github.io/post/leetcode4/</guid>
      <description>4.寻找两个正序数组的中位数 题目链接
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
算法的时间复杂度应该为 O(log (m+n)) 。
示例1：
输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例2：
输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例3：
输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例4：
输入：nums1 = [], nums2 = [1] 输出：1.00000 示例5：
输入：nums1 = [2], nums2 = [] 输出：2.</description>
    </item>
    
    <item>
      <title>【LeetCode】1.两数之和（未完）</title>
      <link>https://lyrace.github.io/post/leetcode1/</link>
      <pubDate>Fri, 28 Jan 2022 22:19:42 +0800</pubDate>
      
      <guid>https://lyrace.github.io/post/leetcode1/</guid>
      <description>1.两数之和 题目链接
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例2：
输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：
输入：nums = [3,3], target = 6 输出：[0,1] 提示：
 2 &amp;lt;= nums.length &amp;lt;= 104 -109 &amp;lt;= nums[i] &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 只会存在一个有效答案  遍历 class Solution { public int[] twoSum(int[] nums, int target) { int[] c = new int[2]; for(int i = 0; i &amp;lt; nums.</description>
    </item>
    
  </channel>
</rss>
