[{"content":"69.x的平方根 题目链接\n给你一个非负整数 x ，计算并返回 x 的算术平方根 。\n由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例1：\n输入：x = 4 输出：2 示例2：\n输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示：\n 0 \u0026lt;= x \u0026lt;= 2 ^31^ - 1  二分查找 class Solution { public int mySqrt(int x) { int left = 1; int right = x; int mid = x / 2; while(left \u0026lt;= right){ if(mid * mid == x){ // 算数平方根是整数的  return mid; } // 乘法超出int范围-\u0026gt;long  else if((long)mid * mid \u0026lt; x){ // mid * mid 比 x 小  if((long)(mid + 1) * (mid + 1) \u0026gt; x){ // mid * mid 比 x 小且(mid + 1) * (mid + 1)比 x 大  return mid; }else if((long)(mid + 1) * (mid + 1) == x) { // mid * mid 比 x 小且(mid + 1) * (mid + 1)等于x  return mid + 1; }else{ // 否则查找范围在右半边  left = mid + 1; } }else if((long)mid * mid \u0026gt; x){ // 查找范围在左半边  right = mid - 1; } mid = left + (right - left) / 2; } return 0; } }  官方题解  class Solution { public int mySqrt(int x) { int l = 0, r = x, ans = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } } 牛顿迭代法 ","permalink":"https://lyrace.github.io/post/leetcode69/","summary":"69.x的平方根 题目链接\n给你一个非负整数 x ，计算并返回 x 的算术平方根 。\n由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例1：\n输入：x = 4 输出：2 示例2：\n输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示：\n 0 \u0026lt;= x \u0026lt;= 2 ^31^ - 1  二分查找 class Solution { public int mySqrt(int x) { int left = 1; int right = x; int mid = x / 2; while(left \u0026lt;= right){ if(mid * mid == x){ // 算数平方根是整数的  return mid; } // 乘法超出int范围-\u0026gt;long  else if((long)mid * mid \u0026lt; x){ // mid * mid 比 x 小  if((long)(mid + 1) * (mid + 1) \u0026gt; x){ // mid * mid 比 x 小且(mid + 1) * (mid + 1)比 x 大  return mid; }else if((long)(mid + 1) * (mid + 1) == x) { // mid * mid 比 x 小且(mid + 1) * (mid + 1)等于x  return mid + 1; }else{ // 否则查找范围在右半边  left = mid + 1; } }else if((long)mid * mid \u0026gt; x){ // 查找范围在左半边  right = mid - 1; } mid = left + (right - left) / 2; } return 0; } }  官方题解  class Solution { public int mySqrt(int x) { int l = 0, r = x, ans = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } } 牛顿迭代法 ","title":"【LeetCode】69.x的平方根(未完)"},{"content":"类变量和类方法 一、类变量 1.1 什么是类变量 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象访问时，取到的都是相同值，任何一个该类的对象去修改时，修改的也是同一个变量。\n1.2 定义类变量 访问修饰符 static 数据类型 变量名；[推荐]\nstatic 访问修饰符 数据类型 变量名；\n1.3 访问类变量 类名.类变量名 或 对象名.类变量名\n静态变量的访问修饰符的访问权限和范围和普通属性是一样的。\npublic class VisticStatic { public static void main(String[] args) { //类名.类变量名  //类变量随着类的加载而创建，没有创建对象实例也可以访问  System.out.println(A.name); A a = new A(); //对象名.类变量名  System.out.println(\u0026#34;a.name=\u0026#34; + a.name); } } class A{ // 类变量的访问必须遵守访问权限  public static String name = \u0026#34;lll\u0026#34;; // 类变量  private int num = 10; // 普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量 } 1.4 类变量的内存布局 有不同说法 可能由于jdk版本不同 在堆或者静态域\n但 static变量是对象共享，在类加载时就生成了\n1.5 注意事项   什么时候使用类变量 需要让某个类的所有对象共享一个变量时\n  类变量与实例变量（普通属性）区别 类变量是该类的所有对象共享的，实例变量是每个对象独享的。\n  加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量\n  实例变量不能通过类名.类变量名访问\n  类变量的生命周期随类的加载开始，随类消亡而销毁\n  public class StaticDetail { public static void main(String[] args) { B b = new B(); // System.out.println(B.n1);//没static，不能用类名.变量名表示  System.out.println(B.n2); //静态变量是类加载的时候，就创建了,没有创建对象实例也可以通过类名.类变量名来访问  System.out.println(C.address); } } class B{ public int n1 = 100; public static int n2 = 200; } class C{ public static String address = \u0026#34;xxx\u0026#34;; } 二、类方法 2.1 类方法也叫静态方法\n访问修饰符 static 数据返回类型 方法名(){} 【推荐】\nstatic 访问修饰符 数据返回类型 方法名(){}\n2.2 类方法的调用 类名.类方法名 或 对象名.类方法名\npublic class StaticMethod { public static void main(String[] args) { Stu tom = new Stu(\u0026#34;tom\u0026#34;); //tom.payFee(100);或  Stu.payFee(100); Stu mary = new Stu(\u0026#34;mary\u0026#34;); //mary.payFee(200);或  Stu.payFee(200); Stu.showFee(); // 300  } } class Stu { private String name;//普通成员  //静态变量累加学生学费  private static double fee = 0; public Stu(String name) { this.name = name; } //static修饰后，该方法是静态方法，静态方法可以访问静态属性/变量  public static void payFee(double fee) { Stu.fee += fee; } public static void showFee() { System.out.println(\u0026#34;总学费有：\u0026#34; + Stu.fee); } } 2.3 使用场景 方法中不涉及任何和对象相关的成员，如工具类中的方法 Math类，开方 Math.sqrt(9);\n2.4 注意事项 类方法和普通方法都是随类的加载而加载，将结构信息存储在方法区\n类方法中无this的参数，普通方法中隐含着this的参数\n类方法不允许使用和对象有关的关键字，如this和super\n类方法中只能访问静态变量或静态方法，普通成员方法，既可以访问静态成员也可以访问非静态成员（成员即变量和方法）。\n","permalink":"https://lyrace.github.io/post/java11/","summary":"类变量和类方法 一、类变量 1.1 什么是类变量 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象访问时，取到的都是相同值，任何一个该类的对象去修改时，修改的也是同一个变量。\n1.2 定义类变量 访问修饰符 static 数据类型 变量名；[推荐]\nstatic 访问修饰符 数据类型 变量名；\n1.3 访问类变量 类名.类变量名 或 对象名.类变量名\n静态变量的访问修饰符的访问权限和范围和普通属性是一样的。\npublic class VisticStatic { public static void main(String[] args) { //类名.类变量名  //类变量随着类的加载而创建，没有创建对象实例也可以访问  System.out.println(A.name); A a = new A(); //对象名.类变量名  System.out.println(\u0026#34;a.name=\u0026#34; + a.name); } } class A{ // 类变量的访问必须遵守访问权限  public static String name = \u0026#34;lll\u0026#34;; // 类变量  private int num = 10; // 普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量 } 1.","title":"【Java笔记】11 类变量和类方法"},{"content":"34.在排序数组中查找元素的第一个和最后一个位置 题目链接\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n示例1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例2：\n输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例3：\n输入：nums = [], target = 0 输出：[-1,-1] 提示：\n  0 \u0026lt;= nums.length \u0026lt;= 105\n  -109 \u0026lt;= nums[i] \u0026lt;= 109\n  nums 是一个非递减数组\n  -109 \u0026lt;= target \u0026lt;= 109\n  二分法 class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid = nums.length / 2; while(left \u0026lt;= right){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ right = mid - 1; }else{ left = mid + 1; } mid = left + (right - left) / 2; } return mid; } } ","permalink":"https://lyrace.github.io/post/leetcode34/","summary":"34.在排序数组中查找元素的第一个和最后一个位置 题目链接\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n示例1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例2：\n输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例3：\n输入：nums = [], target = 0 输出：[-1,-1] 提示：\n  0 \u0026lt;= nums.length \u0026lt;= 105\n  -109 \u0026lt;= nums[i] \u0026lt;= 109\n  nums 是一个非递减数组\n  -109 \u0026lt;= target \u0026lt;= 109\n  二分法 class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.","title":"【LeetCode】34. 在排序数组中查找元素的第一个和最后一个位置"},{"content":"35.搜索插入位置 题目链接\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为O(log n)的算法。\n示例1：\n输入: nums = [1,3,5,6], target = 5 输出: 2 示例2：\n输入: nums = [1,3,5,6], target = 2 输出: 1 示例3：\n输入: nums = [1,3,5,6], target = 7 输出: 4 示例4：\n输入: nums = [1,3,5,6], target = 0 输出: 0 示例5：\n输入: nums = [1], target = 0 输出: 0 提示：\n 1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 为无重复元素的升序排列数组 -104 \u0026lt;= target \u0026lt;= 104  二分法 class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid = nums.length / 2; while(left \u0026lt;= right){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ right = mid - 1; }else{ left = mid + 1; } mid = left + (right - left) / 2; } return mid; } } ","permalink":"https://lyrace.github.io/post/leetcode35/","summary":"35.搜索插入位置 题目链接\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为O(log n)的算法。\n示例1：\n输入: nums = [1,3,5,6], target = 5 输出: 2 示例2：\n输入: nums = [1,3,5,6], target = 2 输出: 1 示例3：\n输入: nums = [1,3,5,6], target = 7 输出: 4 示例4：\n输入: nums = [1,3,5,6], target = 0 输出: 0 示例5：\n输入: nums = [1], target = 0 输出: 0 提示：\n 1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 为无重复元素的升序排列数组 -104 \u0026lt;= target \u0026lt;= 104  二分法 class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.","title":"【LeetCode】35.搜索插入位置"},{"content":"704.二分查找 题目链接\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例1：\n输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例2：\n输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。  二分查找 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid = nums.length / 2; while(left \u0026lt;= right){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ // 目标在nums[mid]左侧  right = mid -1; }else{ // 目标在nums[mid]右侧  left = mid + 1; } mid = (left + right) / 2; // mid = left + (right - left) / 2; 防止溢出  } return -1; } }  mid = (left + right) / 2; \u0026ndash;\u0026gt; mid = left + (right - left) / 2，当left和right很大时，相加可能会溢出，相减不会。  ","permalink":"https://lyrace.github.io/post/leetcode704/","summary":"704.二分查找 题目链接\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例1：\n输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例2：\n输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。  二分查找 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.","title":"【LeetCode】704.二分查找"},{"content":"4.寻找两个正序数组的中位数 题目链接\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n示例1：\n输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例2：\n输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例3：\n输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例4：\n输入：nums1 = [], nums2 = [1] 输出：1.00000 示例5：\n输入：nums1 = [2], nums2 = [] 输出：2.00000 自己写的，时间复杂度O(m+n)  归并，合成一个数组  class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length; int n = nums2.length; int total = m + n; int z = (m + n) / 2; double[] arr = new double[m + n]; int i = 0, j = 0, k = 0; double zhong; // 如果有一个数组长度为0，不进行数组拼接  if (m == 0) { if (total % 2 == 0) { zhong = (nums2[z - 1] + nums2[z]) / 2.0; } else { zhong = nums2[z]; } return zhong; } else if (n == 0) { if (total % 2 == 0) { zhong = (nums1[z - 1] + nums1[z]) / 2.0; } else { zhong = nums1[z]; } return zhong; } else { while ((i \u0026lt; m) \u0026amp;\u0026amp; (j \u0026lt; n)) { if (nums1[i] \u0026lt; nums2[j]) { arr[k] = nums1[i]; k++; i++; } else { arr[k] = nums2[j]; k++; j++; } } if (nums1[m - 1] \u0026lt; nums2[n - 1]) { for (; k \u0026lt; total; k++) { arr[k] = nums2[j]; j++; } } else { for (; k \u0026lt; total; k++) { arr[k] = nums1[i]; i++; } } if (total % 2 == 0) { zhong = (arr[z - 1] + arr[z]) / 2.0; } else { zhong = arr[z]; } return zhong; } } }  不归并，两个指针，将较小指针后移一位，直到中位数位置  二分查找，时间复杂度：O(log(m+n)) 转化成寻找两个有序数组中的第 k 小的数，其中 k为 (m+n)/2 或 (m+n)/2+1\n","permalink":"https://lyrace.github.io/post/leetcode4/","summary":"4.寻找两个正序数组的中位数 题目链接\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n示例1：\n输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例2：\n输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例3：\n输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例4：\n输入：nums1 = [], nums2 = [1] 输出：1.00000 示例5：\n输入：nums1 = [2], nums2 = [] 输出：2.","title":"【LeetCode】4.寻找两个正序数组的中位数（未完）"},{"content":"1.两数之和 题目链接\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例2：\n输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n 2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案  遍历 class Solution { public int[] twoSum(int[] nums, int target) { int[] c = new int[2]; for(int i = 0; i \u0026lt; nums.length; i++) for(int j = i+1; j\u0026lt;nums.length; j++){ if(nums[i] + nums[j] == target){ c[0] = i; c[1] = j; return new int[]{i, j}; } } return new int[0]; } } ","permalink":"https://lyrace.github.io/post/leetcode1/","summary":"1.两数之和 题目链接\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例2：\n输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n 2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案  遍历 class Solution { public int[] twoSum(int[] nums, int target) { int[] c = new int[2]; for(int i = 0; i \u0026lt; nums.","title":"【LeetCode】1.两数之和（未完）"},{"content":"【Java笔记】10 递归 猴子吃桃 有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个。以后每天猴子都吃其中的一半，然后再多吃一个。当到第10天时，想再吃时，发现只有一个桃子了。问：最初共多少个桃子？\npublic calss Recursion{ public static void main(String[] args){ T t1 = new T(); int day = 0; int peachNum = t1.peach(day); if(peachNum != -1){ System.out.println(\u0026#34;第\u0026#34;+day+\u0026#34;天有\u0026#34;+peachNum+\u0026#34;个桃子\u0026#34;); } } } class T{ /* 1.day=10时 有1个桃子 2.day=9时 有(day10+1)*2=4 3.day=8时 有(day9+1)*2=10 前一天的桃子=(后一天的桃子+1)*2 */ public int peach(int day){ if(day == 10){//第10天，只有1个桃  return 1; }else if(day \u0026gt;= 1\u0026amp;\u0026amp;day \u0026lt;= 9){ return (peach(day+1)+1)*2; }else{ System.out.println(\u0026#34;day在1-10\u0026#34;); return -1; } } } 迷宫问题 public class MiGong{ public static void main(String[] args){ //先创建迷宫，用二维数组表示 int[][] map=new int[8][7]; \t//先规定map数组的元素值：0表示可以走 1表示障碍物 \tint[][] map = new int[8][7]; //设置障碍物 \tfor(int i = 0;i \u0026lt; 7;i++){ map[0][i] = 1; map[7][i] = 1; } for(int i = 0;i \u0026lt; 8;i++){ map[i][0] = 1; map[i][6] = 1; } //输出当前的地图 \tSystem.out.println(\u0026#34;===当前地图情况===\u0026#34;); for(int i = 0;i \u0026lt; map.length;i++){ for(int j = 0;j \u0026lt; map[i].length;j++){ System.out.println(map[i][j]+\u0026#34; \u0026#34;); } System.out.println(); } //使用findWay找路 \tT t1 = new T(); //下右上左 \tt1.findWay(map,1,1); System.out.println(\u0026#34;\\n===找路的情况如下===\u0026#34;); for(int i = 0;i \u0026lt; map.length;i++){ for(int j = 0;j \u0026lt; map[i].length;j++){ System.out.println(map[i][j]+\u0026#34; \u0026#34;); } System.out.println(); } } } class T{ /* findWay用来找出迷宫的路径 如果找到，就返回true，否则返回false map就是二维数组，即表示迷宫 i,j就是老鼠的位置，初始化的位置为(1,1) map数组的各个值的含义 0表示可以走 1表示障碍物 2表示可以走 3表示走过，但走不通是死路 当map[6][5]=2就说明找到通路，就可以结束，否则就继续找 找路策略 下-\u0026gt;右-\u0026gt;上-\u0026gt;左 */ public boolean findWay(int[][] map,int i,int j){ if(map[6][5] == 2){//说明已经找到 \treturn true; }else{ if(map[i][j] == 0){//当前这个位置0，说明表示可以走 \tmap[i][j] = 2; //使用找路策略，来确定该位置是否真的可以走通 \tif(findWay(map,i+1,j)){ return true; }else if(findWay(map,i,j+1)){ return true; }else if(findWay(map,i-1,j)){ return true; }else if(findWay(map,i,j-1)){ return true; }else{ map[i][j] = 3; return false; } }else{ return false; } } } } 汉诺塔 汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子， 在一根柱子上从下往上按照大小顺序摞着 64 片圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一 根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\npublic class HanoiTower{ public static void main(String[] args){ Tower tower = new Tower(); tower.move(64,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;); } } class Tower{ //num表示要移动的个数，a,b,c分别表示A塔，B塔，C塔 \tpublic void move(int num,char a,char b,char c){ //如果只有一个盘 num=1 \tif(num == 1){ System.out.println(a+\u0026#34;-\u0026gt;\u0026#34;+c); }else{ //如果有多个盘，可以看成两个，最下面的和上面的所有盘 \t//先移动上面所有的盘到b，借助c \tmove(num-1,a,c,b); //把最下面的这个盘，移动到c \tSystem.out.println(a+\u0026#34;-\u0026gt;\u0026#34;+c); //再把b塔的所有盘，移动到c，借助a \tmove(num-1,b,a,c); } } } ","permalink":"https://lyrace.github.io/post/java10/","summary":"【Java笔记】10 递归 猴子吃桃 有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个。以后每天猴子都吃其中的一半，然后再多吃一个。当到第10天时，想再吃时，发现只有一个桃子了。问：最初共多少个桃子？\npublic calss Recursion{ public static void main(String[] args){ T t1 = new T(); int day = 0; int peachNum = t1.peach(day); if(peachNum != -1){ System.out.println(\u0026#34;第\u0026#34;+day+\u0026#34;天有\u0026#34;+peachNum+\u0026#34;个桃子\u0026#34;); } } } class T{ /* 1.day=10时 有1个桃子 2.day=9时 有(day10+1)*2=4 3.day=8时 有(day9+1)*2=10 前一天的桃子=(后一天的桃子+1)*2 */ public int peach(int day){ if(day == 10){//第10天，只有1个桃  return 1; }else if(day \u0026gt;= 1\u0026amp;\u0026amp;day \u0026lt;= 9){ return (peach(day+1)+1)*2; }else{ System.out.println(\u0026#34;day在1-10\u0026#34;); return -1; } } } 迷宫问题 public class MiGong{ public static void main(String[] args){ //先创建迷宫，用二维数组表示 int[][] map=new int[8][7]; \t//先规定map数组的元素值：0表示可以走 1表示障碍物 \tint[][] map = new int[8][7]; //设置障碍物 \tfor(int i = 0;i \u0026lt; 7;i++){ map[0][i] = 1; map[7][i] = 1; } for(int i = 0;i \u0026lt; 8;i++){ map[i][0] = 1; map[i][6] = 1; } //输出当前的地图 \tSystem.","title":"【Java笔记】10 递归"},{"content":"【Java笔记】09 面向对象 一、类与对象  属性 成员属性=属性=field\t访问修饰符 属性类型 属性名； 访问修饰符：public protected 默认 private 属性不赋值有默认值，跟数组默认值相同 方法（成员方法） 当程序执行到方法时，开辟一个独立的栈空间； 执行完毕，或者到return语句时，返回； 返回到调用方法的语句，继续执行后面的代码 方法的定义： 访问修饰符 返回数据类型 方法名（形参列表..）{//方法体 语句； return 返回值； }  同一个类中的方法调用，直接调用即可，不需要创建对象\nclass A{ //同一个类中的方法调用，直接调用即可，不需要创建对象 \tpubilc void print(int n){ System.out.println(\u0026#34;输出\u0026#34;); } public void test(){ print(); } } 跨类中的方法调用：A类调用B类方法，需要通过对象名调用。即创建B类的对象，再调用方法\n二、方法重载 java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致 方法名：必须相同 形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求） 返回类型：无要求\n三、可变参数 java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法 可变参数的实参可以为0个或任意多个 可变参数的实参可以为数组 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 一个形参列表中最多只能出现一个可变参数\npublic class VarParameter{ public static void main(String[] args){ //求2个、3个、4个...参数的和 \tHspMethod m = new HspMethod(); System.out.println(m.sum(1,5,100)); System.out.println(m.sum(1,19)); } } class HspMethod{ //int...表示接受的是可变参数，类型是int，即可接收多个int（0-多） \t//使用可变参数时，可以当做数组来使用，即nums可以当做数组 \t//遍历nums求和即可 \tpublic int sum(int... nums){ int res = 0; for(int i =0;i \u0026lt; nums.length;i++){ res += nums[i]; } return res; } } 四、作用域 1.java中，主要的变量就是属性（成员变量）和局部变量 2.局部变量一般是指在成员方法中定义的变量 3.Java作用域分类 全局变量：即属性，作用域为整个类 局部变量：除了属性以外的其他变量，作用域为定义它的代码块中 4.属性可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，没有默认值 5.作用域范围 全局变量/属性：可以被本类使用，或其他类使用（通过对象调用） 局部变量：只能在本类中对于的方法中使用 6.全局变量可以加修饰符，局部变量不能加修饰符\n五、构造方法/构造器 构造方法又叫构造器，是类的一种特殊的方法，主要作用是完成对新对象的初始化 方法名和类名相同 没有返回值 创建对象时，系统自动的调用该类的构造器完成对象的初始化 [修饰符] 方法名（形参列表）{ 方法体； } 1.构造器的修饰符可以默认，也可以时public protected private 2.构造器没有返回值 3.方法名和类名字必须一样 4.参数列表和成员方法规则一样 5.一个类可以定义多个不同的构造器，即构造器重载 6.定义了自己的构造器，默认构造器就覆盖了，除非显式定义一下\npublic class Constructor{ public static void main(String[] args){ //new一个对象时，直接通过构造器初始化 \tPerson p1 = new Person(\u0026#34;jack\u0026#34;,3); } } class Person{ String name; int age; public Person(String pName,int pAge){ name = pName; age = pAge; } } 六、this java虚拟机给每个对象分配this，代表当前对象 this 关键字可以用来访问本类的属性、方法、构造器 this 用于区分当前类的属性和局部变量 访问成员方法的语法：this.方法名(参数列表);\nclass T{ public void f1(){ System.out.println(\u0026#34;f1()\u0026#34;); } public void f2(){ System.out.println(\u0026#34;f2()\u0026#34;); //调用本类的f1 \t//第一种方法 \tf1(); //第二种方法 \tthis.f1(); } } 访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)\nclass T{ public T(){ this(\u0026#34;jack\u0026#34;,20);//访问构造器语法：this(参数列表);必须放置第一条语句 \tSystem.out.println(\u0026#34;T()构造器\u0026#34;); } public T(String name,int age){ System.out.println(\u0026#34;T(String name,int age)构造器\u0026#34;); } } this 不能在类定义的外部使用，只能在类定义的方法中使用\n七、访问修饰符 公开 public 受保护 protected 对子类和同一包的类公开 默认 对同一个包的类公开 私有 private 不对外公开 只有默认和public可以修饰类\n八、封装 把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。 步骤： 1.先对属性私有化，让外部不能直接修改属性 2.提供一个公共的set方法，用于对属性判断并赋值\npublic void setXxx(类型 参数名){ //验证 \t属性 = 参数名; } 3.提供一个公共的get方法，用于获取属性的值\npublic getXxx(){//权限判断 \treturn xx; }  有构造器时想使用set方法，在构造器中使用set  public Person(String name, int age, double salary) { // this.name = name; // this.age = age; // this.salary = salary;  setSalary(salary); setAge(age); setName(name); } 九、继承 多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类（基类，超类），在父类中定义这些相同的属性和方法，子类（派生类）通过extends声明继承父类 子类继承了所有的属性和方法，但私有属性和方法不能在子类直接访问，要通过父类公共的方法； 创建子类时，不管使用子类的哪个构造器，默认都会调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super指定使用父类的哪个构造器，即在子类构造器中写super(对应参数列表)； super()使用时放在构造器的第一行，super只能在构造器中使用； super()和this()都只能放在第一行-\u0026gt;不能同时存在； java所有类都是Object类的子类，Object是所有类的基类； 父类构造器的调用不限于父类，而是一直往上追溯； java单继承，子类最多只能直接继承一个父类； 子类和父类之间要满足is-a关系；\npublic class Encap { public static void main(String[] args) { Son son = new Son(); //内存的布局  // 要按照查找关系来返回信息  // (1) 首先看子类是否有该属性  // (2) 如果子类有这个属性，并且可以访问，则返回信息  // (3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)  // (4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object...  System.out.println(son.name);//返回就是大头儿子  //System.out.println(son.age);//会报错，age是私有的属性  System.out.println(son.getAge());//返回的就是 39  System.out.println(son.hobby);//返回的就是旅游  } } class GrandPa {//爷类  String name = \u0026#34;大头爷爷\u0026#34;; String hobby = \u0026#34;旅游\u0026#34;; } class Father extends GrandPa {//父类  String name = \u0026#34;大头爸爸\u0026#34;; private int age = 39; public int getAge() { return age; } } class Son extends Father { //子类  String name = \u0026#34;大头儿子\u0026#34;; } 十、super关键字 访问父类的属性、方法、构造器： 1.访问属性（不能访问父类的private属性） super.属性名； 2.访问父类的方法，不能访问父类的private方法 super.方法名（参数列表）； 3.访问父类的构造器 super(参数列表)； 只能放在第一句 子类、父类方法有重名时，为了访问父类的成员，用super。没有重名，super，this，直接访问一样 找方法时，顺序： 1.先找本类，如果有，调用 2.如果没有，则找父类。父类如果有，并可以调用，则调用 3.如果父类没有，继续找父类的父类，知道Object 查找方法过程中，找到了但不能访问（比如private），报错\n十一、方法重写/覆盖 子类有一个方法和父类的某个方法的名称、返回类型、参数一样，子类的这个方法覆盖了父类的方法 返回类型父类的返回类型是子类的父类也可以。比如父类返回类型是Object，子类是String 子类方法不能缩小父类方法的访问权限\n 比较方法重载和重写     名称 发生范围 方法名 形参列表 返回类型 修饰符     重载 本类 必须一样 类型，个数或顺序至少有一个不同 无要求 无要求   重写 父子类 必须一样 相同 子类重写的方法，返回类型和父类的返回类型一直或者是其子类 子类方法不能缩小父类方法的访问范围    多态 问题：代码复用性不高 解决方案：多态\u0026ndash;\u0026gt;方法或对象有多种形态\n 方法的多态 方法重载、重写体现多态 对象的多态 （1）一个对象的编译类型和运行类型可以不一致 父类的引用指向子类的对象 Animal an = new Dog(); an的编译类型是Animal，运行类型是Dog （2）编译类型在定义对象时就确定了，不能改变 （3）运行类型时可以变化的 an = new Cat(); an的运行类型变成了Cat，编译类型仍然是Animal （4）编译类型看定义时=的左边，运行类型看=的右边  public class Poly{ //animal编译类型就是Animal，运行类型Dog \tAnimal animal = new Dog(); animal.cry(); //狗叫  //animal编译类型就是Animal，运行类型Cat \tanimal = new Cat(); animal.cry(); //猫叫 } 多态的前提时两个对象/类存在继承关系\n  向上转型 （1）本质：父类的引用指向了子类的对象 （2）语法：父类类型 引用名 = new 子类类型()； （3）可以调用父类中的所有成员（遵循访问权限），不能调用子类中的特有成员 编译阶段 调用哪些方法是编译类型决定的，比如animal想调用Cat类特有的catchMouse()方法编译报错 运行阶段 调用是先从子类开始的，遵循方法调用规则\n  向下转型 子类类型 引用名 = （子类类型）父类引用; Cat cat = (Cat) animal; cat.catchMouse(); 只能强转父类的引用，不能强转父类的对象 父类的引用必须指向的是当前目标类型的对象 Animal animal = new Cat(); //此时的animal指向的是Cat Cat cat = (Cat) animal; //这样才能向下转型成Cat 如果是转成Dog类 不对 向下转型后，可以调用子类类型中所有的成员\n  属性不重写，属性的值看编译类型\n  public class Poly01 { public static void main(String[] args) { //属性没有重写之说！属性的值看编译类型  Base base = new Sub();//向上转型  System.out.println(base.count);// ？ 看编译类型 10  Sub sub = new Sub(); System.out.println(sub.count);//? 20  } } class Base { //父类  int count = 10;//属性 } class Sub extends Base { //子类  int count = 20;//属性 } }  instanceOf 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型 动态绑定机制 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用  public class DynamicBinding { public static void main(String[] args) { //a 的编译类型 A, 运行类型 B  A a = new B();//向上转型  System.out.println(a.sum());//?40 -\u0026gt; 30  System.out.println(a.sum1());//?30-\u0026gt; 20  } } class A {//父类  public int i = 10; //动态绑定机制:  public int sum() {//父类sum()  return getI() + 10;//20 + 10  } public int sum1() {//父类sum1()  return i + 10;//10 + 10  } public int getI() {//父类getI  return i; } } class B extends A {//子类  public int i = 20; // public int sum() { // return i + 20; // }  public int getI() {//子类getI()  return i; } // public int sum1() { // return i + 10; // } }  多态数组 数组的定义类型为父类类型，里面保存的实际元素为子类类型  public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String say(){ return name + \u0026#39;\\t\u0026#39; + age; } } public class Student extends Person{ private double score; public Student(String name, int age, double score) { super(name, age); this.score = score; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } @Override public String say(){ return super.say() + \u0026#34;score=\u0026#34; + score; } public void study(){ System.out.println(getName()+\u0026#34;正在学习\u0026#34;); } } public class Teacher extends Person{ private double salary; public Teacher(String name, int age, double salary) { super(name, age); this.salary = salary; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } @Override public String say(){ return super.say()+\u0026#34;salary=\u0026#34;+salary; } public void teach(){ System.out.println(getName()+\u0026#34;正在讲课\u0026#34;); } } public class PolyArray { public static void main(String[] args) { Person[] persons = new Person[5]; persons[0] = new Person(\u0026#34;jack\u0026#34;,20); persons[1] = new Student(\u0026#34;jack\u0026#34;,18,100); persons[2] = new Student(\u0026#34;smith\u0026#34;,19,30.1); persons[3] = new Teacher(\u0026#34;s\u0026#34;,30,20000); persons[4] = new Teacher(\u0026#34;king\u0026#34;,50,25000); //循环遍历多态数组，调用say()  for(int i = 0;i \u0026lt; persons.length;i++){ System.out.println(persons[i].say());//动态绑定，编译类型是Person，运行类型根据实际情况  if(persons[i] instanceof Student){ //运行类型是不是Student  ((Student)persons[i]).study(); //向下转型  } else if(persons[i] instanceof Teacher){ Teacher teacher = (Teacher) persons[i]; teacher.teach(); } else if(persons[i] != null){ System.out.println(\u0026#34;\u0026#34;); }else{ System.out.println(\u0026#34;类型有误\u0026#34;); } } } }  多态参数 形参为父类类型，实参为子类类型  public class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } public double getAnnual() { return 12.0D * this.salary; } public String getName() { return this.name; } public void setName(String name) { this.name = name; } public double getSalary() { return this.salary; } public void setSalary(double salary) { this.salary = salary; } } public class Manager extends Employee { private double bonus; public Manager(String name, double salary, double bonus) { super(name, salary); this.bonus = bonus; } public double getBonus() { return this.bonus; } public void setBonus(double bonus) { this.bonus = bonus; } public void manage() { System.out.println(\u0026#34;经理 \u0026#34; + this.getName() + \u0026#34; is managing\u0026#34;); } public double getAnnual() { return super.getAnnual() + this.bonus; } } public class Worker extends Employee { public Worker(String name, double salary) { super(name, salary); } public void work() { System.out.println(\u0026#34;普通员工 \u0026#34; + this.getName() + \u0026#34; is working\u0026#34;); } public double getAnnual() { return super.getAnnual(); } } public class PloyParameter { public PloyParameter() { } public static void main(String[] args) { Worker tom = new Worker(\u0026#34;tom\u0026#34;, 2500.0D); Manager milan = new Manager(\u0026#34;milan\u0026#34;, 5000.0D, 200000.0D); PloyParameter ployParameter = new PloyParameter(); ployParameter.showEmpAnnual(tom); ployParameter.showEmpAnnual(milan); ployParameter.testWork(tom); ployParameter.testWork(milan); } public void showEmpAnnual(Employee e) { System.out.println(e.getAnnual()); } public void testWork(Employee e) { if (e instanceof Worker) { ((Worker)e).work(); } else if (e instanceof Manager) { ((Manager)e).manage(); } else { System.out.println(\u0026#34;\u0026#34;); } } }   Object类\n是类层次结构的根类，每个类都使用Object作为超类，所有对象都实现这个类的方法。\n  equals方法\n==和equals的对比：\n==是一个比较运算符，既可以判断基本类型，也可以判断引用类型。基本类型：值是否相等，引用类型：判断地址是否相等。\nequals只能判断引用类型，默认判断地址是否相等，子类中往往重写该方法，判断内容是否相等，如String类型。\n//Object类的equals方法 public boolean equals(Object obj){ return (this == obj); // 比较对象地址是否相同 } //Integer类的equals方法 public boolean equals(Object obj){ if(obj instanceof Integer){ return value == ((Integer)obj).intValue(); } return false; } Integer i1 = new Integer(1000); Integer i1 = new Integer(1000); System.out.println(i1 == i2); // false System.out.println(i1.equals(i2)); //true   hashCode()\n提高具有哈希结构的容器的效率\n两个引用，指向同一个对象，哈希值一样\n两个引用，指向不同对象，哈希值不一样\n哈希值主要依据地址号，不能完全将哈希值等价于地址\npublic class HashCode_ { public static void main(String[] args) { A a = new A(); A a1 = new A(); A a2 = a; System.out.println(a.hashCode()); //1163157884  System.out.println(a1.hashCode()); //1956725890  System.out.println(a2.hashCode()); //1163157884  } } class A {}      toString()\n默认返回：全类名+@+哈希值的十六进制 子类往往重写toString方法，用于返回对象的属性信息\npublic class ToString_ { public static void main(String[] args) { /* Object的toSting() 源码 1. getClass().getName() 类的全类名(包名+类名) 2. Integer.toHexString(hashCode()) 将对象的hashCode值转成16进制字符串 public String toString() { return getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(hashCode()); } */ M m = new M(\u0026#34;小妖怪\u0026#34;, \u0026#34;巡山\u0026#34;, 1000); System.out.println(m.toString()+\u0026#34; hashCode=\u0026#34;+m.hashCode()); // object.M@4554617c hashCode=1163157884  } } class M{ private String name; private String job; private double sal; public M(String name, String job, double sal) { this.name = name; this.job = job; this.sal = sal; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getJob() { return job; } public void setJob(String job) { this.job = job; } public double getSal() { return sal; } public void setSal(double sal) { this.sal = sal; } } 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式\n// 重写toString方法，输出对象的属性 // 使用快捷键即可 alt+insert -\u0026gt; toString @Override public String toString() { // 重写后，默认把对象的属性输出  return \u0026#34;M{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, job=\u0026#39;\u0026#34; + job + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, sal=\u0026#34; + sal + \u0026#39;}\u0026#39;; } M m = new M(\u0026#34;小妖怪\u0026#34;, \u0026#34;巡山\u0026#34;, 1000); System.out.println(m.toString()); // M{name=\u0026#39;小妖怪\u0026#39;, job=\u0026#39;巡山\u0026#39;, sal=1000.0} 直接输出一个对象时，toString方法会被默认的调用\nSystem.out.println(\u0026#34;当直接输出一个对象时，toString方法会被默认调用\u0026#34;); System.out.println(m); // 等价 m.toString() /* 当直接输出一个对象时，toString方法会被默认调用 M{name=\u0026#39;小妖怪\u0026#39;, job=\u0026#39;巡山\u0026#39;, sal=1000.0} */   finalize()\n当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，释放资源\n什么时候被回收：当某个对象没有任何引用时。jvm认为这个对象是一个垃圾对象，使用垃圾回收机制销毁该对象，销毁该对象前，先调用finalize方法\n垃圾回收机制的调用，是由系统决定，也可以通过System.gc()主动触发垃圾回收机制\npublic class Finalize_ { public static void main(String[] args) { Car c = new Car(\u0026#34;车\u0026#34;); // 这时，car对象就是一个垃圾，回收器会回收对象，在销毁对象前，会调用该对象的finalize方法  // 在finalize中，写自己的业务逻辑，比如释放资源：数据库连接，或打开文件..  // 如果不重写，就会调用Object类的finalize，即默认处理  c = null; System.gc();// 主动调用垃圾回收机制  System.out.println(\u0026#34;退出\u0026#34;); } } class Car { private String name; public Car(String name) { this.name = name; } // 重写finalize  @Override protected void finalize() throws Throwable { System.out.println(\u0026#34;销毁\u0026#34;); } }   ","permalink":"https://lyrace.github.io/post/java9/","summary":"【Java笔记】09 面向对象 一、类与对象  属性 成员属性=属性=field\t访问修饰符 属性类型 属性名； 访问修饰符：public protected 默认 private 属性不赋值有默认值，跟数组默认值相同 方法（成员方法） 当程序执行到方法时，开辟一个独立的栈空间； 执行完毕，或者到return语句时，返回； 返回到调用方法的语句，继续执行后面的代码 方法的定义： 访问修饰符 返回数据类型 方法名（形参列表..）{//方法体 语句； return 返回值； }  同一个类中的方法调用，直接调用即可，不需要创建对象\nclass A{ //同一个类中的方法调用，直接调用即可，不需要创建对象 \tpubilc void print(int n){ System.out.println(\u0026#34;输出\u0026#34;); } public void test(){ print(); } } 跨类中的方法调用：A类调用B类方法，需要通过对象名调用。即创建B类的对象，再调用方法\n二、方法重载 java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致 方法名：必须相同 形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求） 返回类型：无要求\n三、可变参数 java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法 可变参数的实参可以为0个或任意多个 可变参数的实参可以为数组 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 一个形参列表中最多只能出现一个可变参数\npublic class VarParameter{ public static void main(String[] args){ //求2个、3个、4个...参数的和 \tHspMethod m = new HspMethod(); System.","title":"【Java笔记】09 面向对象"},{"content":"【Java笔记】08数组 一、介绍 数组存放多个同一类型的数据，是引用类型\n 数组的定义 数据类型[] 数组名 = new 数据类型[大小] int[] a = new int[5];  先声明，再创建 声明：数据类型 数组名[]；或 数据类型[] 数组名；此时为null 创建：数组名=new 数据类型[大小];\n静态初始化 数据类型 数组名[]={元素值，元素值,\u0026hellip;}\n 注意 1.数组创建后，如果没有赋值，有默认值 int 0,short 0,byte 0,long 0 ,float 0.0,double 0.0,char \\u0000,boolean false，String null 2.数组属引用类型，数组型数据是对象（object）  二、数组赋值机制 数组在默认情况下是引用传递，赋的值是地址——\u0026gt;赋值方式为引用传递\n//arr2变化会影响到arr1 \tint[] arr1 = {1,2,3}; int[] arr2 = arr1; arr2[0] = 10; //arr1={10,2,3} 三、应用 排序  内部排序：所有数据加载到内存 外部排序：借助外部存储   冒泡排序 通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素 的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部  //数组[24,69,80,57,13] //第一轮 最大数放最后 24,69,80,57,13-\u0026gt;24,69,80,57,13-\u0026gt;24,69,57,80,13-\u0026gt;24,69,57,13,80  //第二轮 第二大的数放在倒数第二位置 24,69,57,13,80-\u0026gt;24 57 69 13 80-\u0026gt;24 57 13 69 80  //第三轮 第三大的数放在倒数第三位置 24 57 13 69 80-\u0026gt;24 13 57 69 80  //第四轮 第四大的数放在倒数第四位置 13 24 57 69 80 public class BubbleSort { public static void main(String []args) { int[] arr = {24,69,80,57,13}; int temp = 0; for(int i=0;i\u0026lt;arr.length-1;i++){ for(int j = 0;j \u0026lt; arr.length-1-i;j++){ if(arr[j] \u0026gt; arr[j + 1]){ temp = arr[j]; arr[j] = arr[j + 1]; arr[j+1] = temp; } } System.out.println(\u0026#34;\\n==第\u0026#34;+(i+1)+\u0026#34;轮==\u0026#34;); for(int j=0;j \u0026lt; arr.length;j++){ System.out.print(arr[j]+\u0026#34;\\t\u0026#34;); } } } } 查找 顺序查找\nimport java.util.Scanner; //顺序查找 public class SeqSearch { public static void main(String []args) { /*有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏： 从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值 */ String[] names = {\u0026#34;白眉鹰王\u0026#34;,\u0026#34;金毛狮王\u0026#34;,\u0026#34;紫衫龙王\u0026#34;,\u0026#34;青翼蝠王\u0026#34;}; Scanner myScanner = new Scanner(System.in); System.out.println(\u0026#34;请输入名字\u0026#34;); String findName = myScanner.next(); int index = -1; for(int i = 0; i \u0026lt; names.length; i++) { //比较 字符串比较 equals, 如果要找到名字就是当前元素 \tif(findName.equals(names[i])) { System.out.println(\u0026#34;恭喜你找到 \u0026#34; + findName); System.out.println(\u0026#34;下标为= \u0026#34; + i); //把 i 保存到 index \tindex = i; break;//退出 \t} } if(index == -1) { //没有找到 \tSystem.out.println(\u0026#34;sorry ,没有找到 \u0026#34; + findName); } } } 四、多维数组 列数不确定初始化\npublic class MyClass { public static void main(String args[]) { int[][] arr = new int[3][]; for(int i=0;i \u0026lt; arr.length;i++){ arr[i] = new int[i+1]; for(int j = 0;j \u0026lt; arr[i].length;j++){ arr[i][j] = i+1; } } for (int i = 0;i\u0026lt;arr.length;i++){ for(int j=0;j\u0026lt;arr[i].length;j++){ System.out.print(arr[i][j]+\u0026#34; \u0026#34;); } System.out.println(); } } }    String[] str = new String[]{\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;};//ok\n  int[] str = new int[]{1,2,3};//ok\n  public class Insert{ public static void main(String[] args){ /* 已知有个升序的数组，要求插入一个元素，该数组顺序依然是升序的 [10,12,45,90]-\u0026gt;[10,12,23,45,90] 数组扩容+定位 */ int[] arr = {10,12,23,45,90}; int insertNum = 23; int index = -1;//将要插入的位置 \t//遍历arr，if insertNum\u0026lt;=arr[i],i就是插入位 \t//if 遍历完没有 insertNum\u0026lt;=arr[i]，index=arr.length \tfor(int i=0;i\u0026lt;arr.length;i++){ if(insertNum \u0026lt;= arr[i]){ index = i; break; } } if(index == -1){ index = arr.length; } int arrNew = new int[arr.length+1]; for(int i=0,j=0;i\u0026lt;arrNew.length;i++){ if(i != index){ arrNew[i] = arr[j]; j++; }else{ arrNew[i] = insertNum; } } arr = arrNew; for(int i = 0;i\u0026lt;arr.length;i++) System.out.println(arr[i]); } } ","permalink":"https://lyrace.github.io/post/java8/","summary":"【Java笔记】08数组 一、介绍 数组存放多个同一类型的数据，是引用类型\n 数组的定义 数据类型[] 数组名 = new 数据类型[大小] int[] a = new int[5];  先声明，再创建 声明：数据类型 数组名[]；或 数据类型[] 数组名；此时为null 创建：数组名=new 数据类型[大小];\n静态初始化 数据类型 数组名[]={元素值，元素值,\u0026hellip;}\n 注意 1.数组创建后，如果没有赋值，有默认值 int 0,short 0,byte 0,long 0 ,float 0.0,double 0.0,char \\u0000,boolean false，String null 2.数组属引用类型，数组型数据是对象（object）  二、数组赋值机制 数组在默认情况下是引用传递，赋的值是地址——\u0026gt;赋值方式为引用传递\n//arr2变化会影响到arr1 \tint[] arr1 = {1,2,3}; int[] arr2 = arr1; arr2[0] = 10; //arr1={10,2,3} 三、应用 排序  内部排序：所有数据加载到内存 外部排序：借助外部存储   冒泡排序 通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素 的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部  //数组[24,69,80,57,13] //第一轮 最大数放最后 24,69,80,57,13-\u0026gt;24,69,80,57,13-\u0026gt;24,69,57,80,13-\u0026gt;24,69,57,13,80  //第二轮 第二大的数放在倒数第二位置 24,69,57,13,80-\u0026gt;24 57 69 13 80-\u0026gt;24 57 13 69 80  //第三轮 第三大的数放在倒数第三位置 24 57 13 69 80-\u0026gt;24 13 57 69 80  //第四轮 第四大的数放在倒数第四位置 13 24 57 69 80 public class BubbleSort { public static void main(String []args) { int[] arr = {24,69,80,57,13}; int temp = 0; for(int i=0;i\u0026lt;arr.","title":"【Java笔记】08数组"},{"content":"【Java笔记】07 控制结构 三大流程控制语句：顺序控制、分支控制、循环控制\n分支控制 switch 表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型 switch（表达式）中表达式的返回值必须是byte,short,int,char,enum,String case子句中的值必须是常量，而不能是变量、\n//3，4，5月春季，6，7，8月夏季，9，10，11秋季，12，1，2月冬季 \tScanner myScanner = new Scanner(System.in); System.out.println(\u0026#34;输入月份\u0026#34;); int m = myScanner.nextInt(); switch(m){ case 3: case 4: case 5: System.out.println(\u0026#34;春季\u0026#34;); break; case 6: case 7: case 8: System.out.println(\u0026#34;夏季\u0026#34;); break; case 9: case 10: case 11: System.out.println(\u0026#34;秋季\u0026#34;); break; case 12: case 1: case 2: System.out.println(\u0026#34;冬季\u0026#34;); break; default: System.out.println(\u0026#34;输入的月份不对\u0026#34;); } break break语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块 continue语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块\nlabel1: for(int j=0;j\u0026lt;4;j++){ label2: for(int i=0;i\u0026lt;10;i++){ if(i == 2){ break lable1; } System.out.println(\u0026#34;i=\u0026#34;+i); } } ","permalink":"https://lyrace.github.io/post/java7/","summary":"【Java笔记】07 控制结构 三大流程控制语句：顺序控制、分支控制、循环控制\n分支控制 switch 表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型 switch（表达式）中表达式的返回值必须是byte,short,int,char,enum,String case子句中的值必须是常量，而不能是变量、\n//3，4，5月春季，6，7，8月夏季，9，10，11秋季，12，1，2月冬季 \tScanner myScanner = new Scanner(System.in); System.out.println(\u0026#34;输入月份\u0026#34;); int m = myScanner.nextInt(); switch(m){ case 3: case 4: case 5: System.out.println(\u0026#34;春季\u0026#34;); break; case 6: case 7: case 8: System.out.println(\u0026#34;夏季\u0026#34;); break; case 9: case 10: case 11: System.out.println(\u0026#34;秋季\u0026#34;); break; case 12: case 1: case 2: System.out.println(\u0026#34;冬季\u0026#34;); break; default: System.out.println(\u0026#34;输入的月份不对\u0026#34;); } break break语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块 continue语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块\nlabel1: for(int j=0;j\u0026lt;4;j++){ label2: for(int i=0;i\u0026lt;10;i++){ if(i == 2){ break lable1; } System.","title":"【Java笔记】07 控制结构"},{"content":"【Java笔记】06 进制 一、四种进制 整数的四种表示方法： 1.二进制：0，1，满2进1，以0b或0B开头 2.十进制：0-9，满10进1 3.八进制：0-7，满8进1，以数字0开头表示 4.十六进制：0-15，满16进1，以0x或0X开头表示\nint n1 = 0b1010;//二进制，10 \tint n2 = 1010;//十进制，1010 \tint n3 = 01010;//八进制，01010 \tint n4 = 0X10101//十六进制，0X10101 二、进制转换  十进制转二进制 除2取余，注意一个字节8位 34=0B0010 0010 十进制转八进制 除8取余，131=0203 十进制转十六进制 除16取余，237=0xED 二进制转八进制 低位开始，二进制数三位一组，转成八进制 0B11 010 101=\u0026gt;0 3 2 5 二进制转十六进制 低位开始，四位一组 0b1101 0101 =\u0026gt; 0x D 5  三、原码、反码、补码 对于有符号： 1.二进制的最高位是符号位，0表示整数，1表示负数 2.正数的原码、反码、补码都一样 3.负数的反码=原码符号位不变，其它位取反 4.负数的补码=反码+1，负数的反码=负数的补码-1 5.0的反码，补码都是0 6.Java没有无符号数 7.计算机都是以补码的方式运算的 8.看运算结果时，看原码\n四、位运算符  按位与\u0026amp;\t两位全为1，结果为1，否则为0 2\u0026amp;3 1.2的原码=\u0026gt;00000000 00000000 00000000 00000010 2的补码=\u0026gt;00000000 00000000 00000000 00000010 2.3的补码=\u0026gt;00000000 00000000 00000000 00000011 3.按位与\u0026amp; 00000000 00000000 00000000 00000010 00000000 00000000 00000000 00000011 =\u0026gt;00000000 00000000 00000000 00000010 运算后的补码 原码一样 结果是2 按位或|\t两位一个为1，结果为1，否则为0 按位异或^\t两位一个为0，一个为1（两位不一样），结果为1，否则为0 按位取反~\t0-\u0026gt;1,1-\u0026gt;0 算数右移\u0026raquo;：低位溢出，符号位不变，符号位补溢出的高位 int a = 1 \u0026raquo; 2;//1 =\u0026gt; 00000001 =\u0026gt;00000000\t本质1÷2÷2=0 算数左移\u0026laquo;：符号位不变，低位补0 int a = 1 \u0026laquo; 2;//1 =\u0026gt; 00000001 =\u0026gt; 00000100\t本质1×2×2 逻辑右移、无符号右移\u0026raquo;\u0026gt;：低位溢出，高位补0  ","permalink":"https://lyrace.github.io/post/java6/","summary":"【Java笔记】06 进制 一、四种进制 整数的四种表示方法： 1.二进制：0，1，满2进1，以0b或0B开头 2.十进制：0-9，满10进1 3.八进制：0-7，满8进1，以数字0开头表示 4.十六进制：0-15，满16进1，以0x或0X开头表示\nint n1 = 0b1010;//二进制，10 \tint n2 = 1010;//十进制，1010 \tint n3 = 01010;//八进制，01010 \tint n4 = 0X10101//十六进制，0X10101 二、进制转换  十进制转二进制 除2取余，注意一个字节8位 34=0B0010 0010 十进制转八进制 除8取余，131=0203 十进制转十六进制 除16取余，237=0xED 二进制转八进制 低位开始，二进制数三位一组，转成八进制 0B11 010 101=\u0026gt;0 3 2 5 二进制转十六进制 低位开始，四位一组 0b1101 0101 =\u0026gt; 0x D 5  三、原码、反码、补码 对于有符号： 1.二进制的最高位是符号位，0表示整数，1表示负数 2.正数的原码、反码、补码都一样 3.负数的反码=原码符号位不变，其它位取反 4.负数的补码=反码+1，负数的反码=负数的补码-1 5.0的反码，补码都是0 6.Java没有无符号数 7.计算机都是以补码的方式运算的 8.看运算结果时，看原码\n四、位运算符  按位与\u0026amp;\t两位全为1，结果为1，否则为0 2\u0026amp;3 1.2的原码=\u0026gt;00000000 00000000 00000000 00000010 2的补码=\u0026gt;00000000 00000000 00000000 00000010 2.","title":"【Java笔记】06 进制"},{"content":"【Java笔记】05 键盘输入 键盘输入语句 扫描器 Scanner\tjava.util.* 1.导入该类所在的包 2.创建Scanner对象\nimport java.util.Scanner; public class Input{ public static void main(String[] args){ Scanner myScanner = new Scanner(System.in); //执行到next方法时，会等待用户输入 \tString name = myScanner.next();//接收用户输入字符串 \tint age = myScanner.nextInt(); double sal = myScanner.nextDouble(); } } ","permalink":"https://lyrace.github.io/post/java5/","summary":"【Java笔记】05 键盘输入 键盘输入语句 扫描器 Scanner\tjava.util.* 1.导入该类所在的包 2.创建Scanner对象\nimport java.util.Scanner; public class Input{ public static void main(String[] args){ Scanner myScanner = new Scanner(System.in); //执行到next方法时，会等待用户输入 \tString name = myScanner.next();//接收用户输入字符串 \tint age = myScanner.nextInt(); double sal = myScanner.nextDouble(); } } ","title":"【Java笔记】05 键盘输入"},{"content":"【Java笔记】04 运算符 一、算数运算符 运算符：+（正号）、-（负号）、+、-、*、/、%、++、\u0026ndash;、 +（字符串相加） 1./\nSystem.out.println(10 / 4); //2 \tSystem.out.println(10.0 / 4); //2.5 \tdouble d = 10 / 4;//2.0 2.% 取模，取余 %运算， a % b = a - a / b * b 10%3=1\t//10-10/33=1 -10%3=-1\t//(-10)-(-10)/33=-1 10%-3=1\t//10-10/(-3)(-3)=1 %运算，a是小数的情况下， a % b = a - (int)a / b * b -10.5%3 = -10.5 - (-10)/33 = -10.5+9=-1.5 3.++\n 作为独立语句 i++;//自增，等价于 i=i+1； ++i;//自增，等价于i=i+1; 作为表达式使用 前++：++i先自增，后赋值 后++：i++先赋值，后自增  int i = 8; int k = ++i;//i=i+1;k=i; \tSystem.out.println(\u0026#34;k=\u0026#34; + k + \u0026#34;i=\u0026#34; + i); //9 9 \tint j = 8; int l = j++;//k=j;j=j+1; \tSystem.out.println(\u0026#34;j=\u0026#34; + j + \u0026#34;l=\u0026#34; +l);\t//8 9 int i = 1;//i-\u0026gt;1 \ti = i++;//规定 使用临时变量：（1）temp=i;(2)i=i+1;(3)i=temp; \tSystem.out.println(i); // 1 int i = 1;//i-\u0026gt;1 \ti = ++i;//规定 使用临时变量：(1)i=i+1;（2）temp=i;(3)i=temp; \tSystem.out.println(i); // 2 二、关系运算符（比较运算符） 结果都是boolean，即true或false 关系运算符组成的表达式，称为关系表达式 boolean = a \u0026gt; b; 1.==\t相等 2.!=\t不等 3.\u0026lt; 4.\u0026gt; 5.\u0026lt;= 6.\u0026gt;= 7.instance of\t检查是否是类的对象 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。\n三、逻辑运算符  a\u0026amp;b : \u0026amp; 叫逻辑与：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false a\u0026amp;\u0026amp;b : \u0026amp;\u0026amp; 叫短路与：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false    \u0026amp;和\u0026amp;\u0026amp;的区别 1.\u0026amp;\u0026amp;短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false，效率高 2.\u0026amp;逻辑与：不管第一个条件是否为false，第二个条件都要判断，效率低  int a = 4; int b = 9; //对\u0026amp;\u0026amp;，如果第一个条件为false，后面的条件不再判断，即++b不执行 \tif(a \u0026lt; 1 \u0026amp;\u0026amp; ++b \u0026lt; 50){ System.out.println(\u0026#34;ok\u0026#34;); } System.out.println(\u0026#34;a=\u0026#34; + a + \u0026#34;b=\u0026#34; + b); //4 9 \t//对\u0026amp;，如果第一个条件为false，后面的条件判断，即++b执行 \tif(a \u0026lt; 1 \u0026amp; ++b \u0026lt; 50){ System.out.println(\u0026#34;ok\u0026#34;); } System.out.println(\u0026#34;a=\u0026#34; + a + \u0026#34;b=\u0026#34; + b); //4 10  a|b : | 叫逻辑或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false a||b : || 叫短路或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false    |和||的区别 1.||短路或：如果第一个条件为true，后面条件不判断，最终结果为true 2.|逻辑或：如果第一个条件为true，后面条件判断，最终结果为true   !a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false  int x = 5; int y = 5; //x++ == 6,后++,先比较后自增，比较5==6，false；x自增=6; \t//++y == 6,先++，先自增后比较，y自增=6；比较6=6，true; \tif(x++ == 6 \u0026amp; ++y == 6){ x=11; } System.out.println(x,y); // 6 6 四、赋值运算符 1.基本赋值运算符= 2.复合赋值运算符 +=，-=，/=，%= 复合赋值运算符会进行类型转换\nbyte b = 3; b += 2;\t//等价于 b = (byte)(b + 2); 五、三元运算符 条件表达式？表达式1：表达式2； 表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换）\n六、运算符优先级     . () {} ; ,     R-\u0026gt;L ++ \u0026ndash;\t~ !   L-\u0026gt;R * / + -   L-\u0026gt;R + -   L-\u0026gt;R \u0026laquo; \u0026raquo; \u0026raquo;\u0026gt; 位移   L-\u0026gt;R \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= instanceof   L-\u0026gt;R == !=   L-\u0026gt;R \u0026amp;   L-\u0026gt;R ^   L-\u0026gt;R |   L-\u0026gt;R \u0026amp;\u0026amp;   L-\u0026gt;R ||   L-\u0026gt;R ? :   R-\u0026gt;L = *= /= %=    += -= \u0026laquo;= \u0026raquo;=    \u0026raquo;\u0026gt;= \u0026amp;= ^= |=   从上到下优先级降低     ","permalink":"https://lyrace.github.io/post/java4/","summary":"【Java笔记】04 运算符 一、算数运算符 运算符：+（正号）、-（负号）、+、-、*、/、%、++、\u0026ndash;、 +（字符串相加） 1./\nSystem.out.println(10 / 4); //2 \tSystem.out.println(10.0 / 4); //2.5 \tdouble d = 10 / 4;//2.0 2.% 取模，取余 %运算， a % b = a - a / b * b 10%3=1\t//10-10/33=1 -10%3=-1\t//(-10)-(-10)/33=-1 10%-3=1\t//10-10/(-3)(-3)=1 %运算，a是小数的情况下， a % b = a - (int)a / b * b -10.5%3 = -10.5 - (-10)/33 = -10.5+9=-1.5 3.++\n 作为独立语句 i++;//自增，等价于 i=i+1； ++i;//自增，等价于i=i+1; 作为表达式使用 前++：++i先自增，后赋值 后++：i++先赋值，后自增  int i = 8; int k = ++i;//i=i+1;k=i; \tSystem.","title":"【Java笔记】04 运算符"},{"content":"【Java笔记】03 变量 一、变量基本  概念  变量是程序的基本组成单位，相当于内存中一个数据存储空间的表示，基本要素（类型、名称、值）\n 步骤   声明变量 int a; 赋值 a=60; 使用 System.out.println(a);   注意事项 1.变量表示内存中的一个存储区域 2.该区域有名称和内存 3.先声明后使用 4.该区域的数据在同一类型范围内变化 5.变量在同一作用域不能重名  二、+的使用 1.左右都是数值型=\u0026gt;加法运算 2.左右两边有一方为字符串=\u0026gt;拼接运算\nSystem.out.println(100+98);//198 System.out.println(\u0026#34;100\u0026#34;+98);//10098 System.out.println(100+3+\u0026#34;hello\u0026#34;);//103hello System.out.println(\u0026#34;hello\u0026#34;+100+3);//hello1003 三、数据类型 1.基本数据类型\n 数值型 整数类型，存放整数 byte(字节)[1],short[2],int[4],long[8] 浮点类型 float[4],double[8] 字符型 存放单个字符 char[2] 布尔型 存放true,false boolean[1] 2.引用数据类型 类 接口 数组  四、整数类型    类型 占用存储空间 范围     byte,字节 1字节 -128~127   short,短整型 2字节 -2^15^ ~ 2^15^-1，-32768~32767   int,整型 4字节 -2^31^ ~ 2^31^-1，-2147483648~2147483647   long,长整型 8字节 -2^63^ ~ 2^63^-1      坑  double num1 = 2.7; double num2 = 8.1/3; System.out.println(num1); //2.7 \tSystem.out.println(num2); //接近2.7的一个小数，而不是2.7 对运算结果是小数的进行相等判断时，Pay Attention! 正确写法：\nif(Math.abs(num1 - num2) \u0026lt; 0.000001) { //差值非常小，达到要求精度 \tSystem.out.println(\u0026#34;相等\u0026#34;); } 但直接赋值时，两数可判断相等。\n六、字符类型 字符类型可以直接存放一个数字 char c=97;\n1.字符常量单引号 2.允许用转义字符 char c = \u0026lsquo;\\t\u0026rsquo;; 3.Java中，char的本质是一个整数，在输出时，对应unicode码对应的字符 4.char类型是可以进行运算的，相当于一个整数\nSystem.out.println(\u0026#39;a\u0026#39; + 10);//107 \tchar c5 = \u0026#39;b\u0026#39; + 1;//98+1==\u0026gt; 99 \tSystem.out.println((int)c5); //99 \tSystem.out.println(c5); //99-\u0026gt;ASCII码=\u0026gt;c  字符类型本质 字符存储到计算机中，将对应的码值找出来 存储：\u0026lsquo;a\u0026rsquo;=\u0026gt;码值 97=\u0026gt;二进制 110 0001=\u0026gt;存储 读取：二进制 110 0001=\u0026gt;97=\u0026gt;\u0026lsquo;a\u0026rsquo;=\u0026gt;显示 编码表 ASCII 一个字节表示，128个字符。实际上一个字节可以表示256个字符，只用了128个 Unicode 固定大小的编码，使用两个字节来表示字符，字母和汉字都是占用两个字节，浪费空间 utf-8 大小可变的编码，字母使用1个字节，汉字使用3个字节 gbk 可表示汉字，范围更广泛，字母使用1个字节，汉字使用2个字节 gb2312 可以表示汉字，少用 big5 繁体汉字  七、布尔类型 占1个字节，适用于逻辑运算 只允许取值true和false 不能用0或非0代替false和true\n八、数据类型转换  自动类型转换 1.精度小的类型自动转换为精度大的数据类型 char -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double byte -\u0026gt; short -\u0026gt;int -\u0026gt; long -\u0026gt; float -\u0026gt;double 2.有多种类型的数据混合运算时，系统首先将所有数据转换成容量最大的那种数据类型，再进行计算  public class Convert{ public static void main (String[] args){ int n1 = 10; //float d1 = n1 + 1.1;//错误 n1+1.1结果是double类型 \tdouble d1 = n1 + 1.1;//✔ \tfloat d = n1 + 1.1F;//✔ \t} } 3.byte和short不能跟char进行自动类型转换 当把数赋给byte时，先判断该数是否在byte范围内\nbyte b1 = 10;//✔ -128~127 \tbyte b = 1000;//✘\t超出范围 \tint n2 = 1; byte b2 = n2;//✘ 变量赋值，会判断类型 \tchar c1 = b1;//✘ 4.byte,short,char可以进行运算，都转成int\nbyte b2 = 1; byte b3 = 2; short s1 = 1; short s2 = b2 + s1;//✘\tbyte和short运算时转成int，再赋值给小精度的short类型报错 \tbyte b4 = b2 + b3;//✘\tbyte和byte运算时转成int 5.boolean类型不参与自动类型转换\n 强制类型转换 自动类型转换的逆过程，容量大的数据类型转换为容量小的，可能造成精度降低或溢出 e.g.:int i = (int)1.9; 强转符号只对最近的操作数有效  int x = (int)10*3.5+6*1.5;//编译错误：只强转了10，结果是double-\u0026gt;int \tint y = (int)(10*3.5+6*1.5);//(int)44.0-\u0026gt;44 char类型可以保存int的常量值，但不能保存int的变量值，需要强转\nchar c1 = 100;//right \tint m = 100; char c2 = m;//错误 \tchar c3 = (char)m;//right\t100对应的字符 d  基本数据类型和String类型的转换   基本类型转String 加 \u0026quot; \u0026quot;  int n1 = 100; float f1 = 1.1F; double d1 = 4.5; boolean b1 = true; String s1 = n1 + \u0026#34;\u0026#34;; String s2 = f1 + \u0026#34;\u0026#34;; String s3 = d1 + \u0026#34;\u0026#34;; String s4 = b1 + \u0026#34;\u0026#34;; String类型转基本数据类型 基本类型的包装类调用parseXX方法即可  String s5 = \u0026#34;123\u0026#34;; int num = Integer.parseInt(s5); double num1 = Double.parseDouble(s5); float num2 = Float.parseFloat(s5); long num3 = Long.parseLong(s5); byte num4 = Byte.parseByte(s5); boolean b = Boolean.parseBoolean(\u0026#34;true\u0026#34;); short num5 = Short.parseShort(s5); //字符串-\u0026gt;字符，取字符串第一个字符 \tSystem.out.println(s5.charAt(0));//1 ","permalink":"https://lyrace.github.io/post/java3/","summary":"【Java笔记】03 变量 一、变量基本  概念  变量是程序的基本组成单位，相当于内存中一个数据存储空间的表示，基本要素（类型、名称、值）\n 步骤   声明变量 int a; 赋值 a=60; 使用 System.out.println(a);   注意事项 1.变量表示内存中的一个存储区域 2.该区域有名称和内存 3.先声明后使用 4.该区域的数据在同一类型范围内变化 5.变量在同一作用域不能重名  二、+的使用 1.左右都是数值型=\u0026gt;加法运算 2.左右两边有一方为字符串=\u0026gt;拼接运算\nSystem.out.println(100+98);//198 System.out.println(\u0026#34;100\u0026#34;+98);//10098 System.out.println(100+3+\u0026#34;hello\u0026#34;);//103hello System.out.println(\u0026#34;hello\u0026#34;+100+3);//hello1003 三、数据类型 1.基本数据类型\n 数值型 整数类型，存放整数 byte(字节)[1],short[2],int[4],long[8] 浮点类型 float[4],double[8] 字符型 存放单个字符 char[2] 布尔型 存放true,false boolean[1] 2.引用数据类型 类 接口 数组  四、整数类型    类型 占用存储空间 范围     byte,字节 1字节 -128~127   short,短整型 2字节 -2^15^ ~ 2^15^-1，-32768~32767   int,整型 4字节 -2^31^ ~ 2^31^-1，-2147483648~2147483647   long,长整型 8字节 -2^63^ ~ 2^63^-1      坑  double num1 = 2.","title":"【Java笔记】03 变量"},{"content":"【Java笔记】02 DOS 一、DOS命令 Dos：Disk Operating System磁盘操作系统\n二、路径 相对路径：从当前目录开始定位形成的一个路径\t..-\u0026gt;上一层 绝对路径：从顶级目录开始定位形成的一个路径\n三、常用的Dos命令 1.查看当前目录有什么内容 dir 路径 2.切换到其他盘 切换到c盘 cd \\D c: 3.切换到当前盘的其他目录下、 cd d:\\abc\\test cd ....\\abc\\test 4.切换到上一级 cd .. 5.切换到根目录 cd 6.查看指定的目录下所有的子级目录 tree 7.清屏 cls 8.推出Dos exit 9.md[创建目录]，rd[删除目录]，copy[拷贝文件]，del[删除文件]，echo[输入内容到文件，echo hello \u0026gt; ok.txt],move[剪切/移动]\n","permalink":"https://lyrace.github.io/post/java2/","summary":"【Java笔记】02 DOS 一、DOS命令 Dos：Disk Operating System磁盘操作系统\n二、路径 相对路径：从当前目录开始定位形成的一个路径\t..-\u0026gt;上一层 绝对路径：从顶级目录开始定位形成的一个路径\n三、常用的Dos命令 1.查看当前目录有什么内容 dir 路径 2.切换到其他盘 切换到c盘 cd \\D c: 3.切换到当前盘的其他目录下、 cd d:\\abc\\test cd ....\\abc\\test 4.切换到上一级 cd .. 5.切换到根目录 cd 6.查看指定的目录下所有的子级目录 tree 7.清屏 cls 8.推出Dos exit 9.md[创建目录]，rd[删除目录]，copy[拷贝文件]，del[删除文件]，echo[输入内容到文件，echo hello \u0026gt; ok.txt],move[剪切/移动]","title":"【Java笔记】02 DOS"},{"content":"【Java笔记】01 概述 一、java特性 1.面向对象的（oop) 2.健壮的，由强制类型机制、异常处理、垃圾的自动收集等保证 3.跨平台性的，一个编译好的class文件可在多个操作系统下运行 4.解释性的 解释性：编译后的代码，不能直接被机器执行，需要解释器来执行,javascript,PHP,java 编译性：编译后的代码，可以直接被机器执行，c/c++\n二、java运行机制及运行过程 JVM让同一个java程序在三个不同的操作系统中都可以执行——\u0026gt;跨平台性 1.java核心机制——java虚拟机[JVM java virtual machine]\n 基本介绍 1.JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK中 2.不同的平台有不同的虚拟机 3.虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行  JDK \u0026amp; JRE 1.JDK 全称Java Development Kit，java开发工具包 JDK=JRE+java的开发工具java，javac，javadoc,javap等 2.JRE Java Runtime Environment，java运行环境 JRE=JVM+Java的核心类库 =\u0026gt;JDK=JVM+Java SE标准类库+开发工具集  三、Java开发注意事项 一个源文件最多只能有一个public类。其它类的个数不限。编译后每一个类都对应一个.class 也可以将main方法写在非public类中，然后指定运行非public类这样入口方法就是非public的main方法\npublic class Hello{ public static void main (String []args){ System.out.println(\u0026#34;Hello,l\u0026#34;); } } public class Hello{ public static void main (String []args){ System.out.println(\u0026#34;Hello,l\u0026#34;); } } class Dog{ public static void main (String []args){ System.out.println(\u0026#34;Hello,d\u0026#34;); } } class Cat{ public static void main (String []args){ System.out.println(\u0026#34;Hello,c\u0026#34;); } } 四、Java转义字符 \\t：一个制表位 \\n：换行符 \\：一个\n\u0026quot;：一个\u0026quot; '：一个' \\r：一个回车，光标移到行首，\\r后面的替换\\r前部分字符\n 回车和换行在命令行和IDEA中实测有区别  五、注释 1.单行注释 //注释文字 ctrl+/同时注释多行 2.多行注释 /注释文字/ 多行注释不能嵌套多行注释 3.文档注释 注释内容可以被jdk提供的工具javadoc所解析，生成一套以网页形式体现的该程序的说明文档，一般写在类 javadoc标签\n//文档注释  /** * @author ace * @version 1.0 */ public class Test { public static void main(String[] args) { System.out.println(\u0026#34;abcde\\rmn\u0026#34;); System.out.println(\u0026#34;------------\u0026#34;); System.out.println(\u0026#34;abcde\\r\\nmn\u0026#34;); } } javadoc -d 文件夹名 -xx -yy 类名.java e.g.:javadoc -d C:\\Users\\ace\\Desktop\\comment -author -version Test.java 六、Java API文档 java8 中文文档 https://www.matools.com/api/java8 七、标识符 不能以数字开头 由26个英文大小写，0-9，_或$组成 包名：多单词组成时所有字母都小写 类名、接口名：多单词组成时，所有单词的首字母大写 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写 常量名：所有字母都大写，多单词时每个单词用下划线连接\n","permalink":"https://lyrace.github.io/post/java1/","summary":"【Java笔记】01 概述 一、java特性 1.面向对象的（oop) 2.健壮的，由强制类型机制、异常处理、垃圾的自动收集等保证 3.跨平台性的，一个编译好的class文件可在多个操作系统下运行 4.解释性的 解释性：编译后的代码，不能直接被机器执行，需要解释器来执行,javascript,PHP,java 编译性：编译后的代码，可以直接被机器执行，c/c++\n二、java运行机制及运行过程 JVM让同一个java程序在三个不同的操作系统中都可以执行——\u0026gt;跨平台性 1.java核心机制——java虚拟机[JVM java virtual machine]\n 基本介绍 1.JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK中 2.不同的平台有不同的虚拟机 3.虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行  JDK \u0026amp; JRE 1.JDK 全称Java Development Kit，java开发工具包 JDK=JRE+java的开发工具java，javac，javadoc,javap等 2.JRE Java Runtime Environment，java运行环境 JRE=JVM+Java的核心类库 =\u0026gt;JDK=JVM+Java SE标准类库+开发工具集  三、Java开发注意事项 一个源文件最多只能有一个public类。其它类的个数不限。编译后每一个类都对应一个.class 也可以将main方法写在非public类中，然后指定运行非public类这样入口方法就是非public的main方法\npublic class Hello{ public static void main (String []args){ System.out.println(\u0026#34;Hello,l\u0026#34;); } } public class Hello{ public static void main (String []args){ System.out.println(\u0026#34;Hello,l\u0026#34;); } } class Dog{ public static void main (String []args){ System.","title":"【Java笔记】01 概述"}]