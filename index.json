[{"content":"844.比较含退格的字符串 题目链接\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n**注意：**如果对空文本输入退格字符，文本继续为空。\n示例1：\n输入：s = \u0026quot;ab#c\u0026quot;, t = \u0026quot;ad#c\u0026quot; 输出：true 解释：s 和 t 都会变成 \u0026quot;ac\u0026quot;。 示例2：\n输入：s = \u0026quot;ab##\u0026quot;, t = \u0026quot;c#d#\u0026quot; 输出：true 解释：s 和 t 都会变成 \u0026quot;\u0026quot;。 示例 3：\n输入：s = \u0026quot;a#c\u0026quot;, t = \u0026quot;b\u0026quot; 输出：false 解释：s 会变成 \u0026quot;c\u0026quot;，但 t 仍然是 \u0026quot;b\u0026quot;。 提示：\n 1 \u0026lt;= s.length, t.length \u0026lt;= 200 s 和 t 只含有小写字母以及字符 '#'  重构字符串 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类\n和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象\nStringBuffer 线程安全\npublic StringBuffer append(String s)\t将指定的字符串追加到此字符序列。\nclass Solution { public boolean backspaceCompare(String S, String T) { return build(S).equals(build(T)); } public String build(String str) { StringBuffer ret = new StringBuffer(); int length = str.length(); for (int i = 0; i \u0026lt; length; ++i) { char ch = str.charAt(i); if (ch != \u0026#39;#\u0026#39;) { ret.append(ch); // 当前字符不是#，将其追加到ret字符串后  } else { if (ret.length() \u0026gt; 0) { ret.deleteCharAt(ret.length() - 1); // 当前字符是#,要在ret最后删除一个字符，完成退格操作  } } } return ret.toString(); } } 双指针 从后往前遍历字符串，可以确定当前字符是否被删除\n用skip表示当前待删除的字符的数量，遍历到一个字符时：\n  若该字符是#，skip++\n  若该字符不是#\n  skip为0时，当前字符不需要删除\n  skip不为0时，当前字符删除，skip\u0026ndash;\n    class Solution844 { public boolean backspaceCompare(String S, String T) { int i = S.length() - 1, j = T.length() - 1; int skipS = 0, skipT = 0; while (i \u0026gt;= 0 || j \u0026gt;= 0) { while (i \u0026gt;= 0) { if (S.charAt(i) == \u0026#39;#\u0026#39;) { skipS++; i--; } else if (skipS \u0026gt; 0) { skipS--; i--; } else { break; } } while (j \u0026gt;= 0) { if (T.charAt(j) == \u0026#39;#\u0026#39;) { skipT++; j--; } else if (skipT \u0026gt; 0) { skipT--; j--; } else { break; } } if (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0) { if (S.charAt(i) != T.charAt(j)) { return false; } } else { if (i \u0026gt;= 0 || j \u0026gt;= 0) { return false; } } i--; j--; } return true; } } ","permalink":"https://lyrace.github.io/post/leetcode844/","summary":"844.比较含退格的字符串 题目链接\n给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n**注意：**如果对空文本输入退格字符，文本继续为空。\n示例1：\n输入：s = \u0026quot;ab#c\u0026quot;, t = \u0026quot;ad#c\u0026quot; 输出：true 解释：s 和 t 都会变成 \u0026quot;ac\u0026quot;。 示例2：\n输入：s = \u0026quot;ab##\u0026quot;, t = \u0026quot;c#d#\u0026quot; 输出：true 解释：s 和 t 都会变成 \u0026quot;\u0026quot;。 示例 3：\n输入：s = \u0026quot;a#c\u0026quot;, t = \u0026quot;b\u0026quot; 输出：false 解释：s 会变成 \u0026quot;c\u0026quot;，但 t 仍然是 \u0026quot;b\u0026quot;。 提示：\n 1 \u0026lt;= s.length, t.length \u0026lt;= 200 s 和 t 只含有小写字母以及字符 '#'  重构字符串 当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类","title":"【Leetcode】844.比较含退格的字符串"},{"content":"283.移动零 题目链接\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例1：\n输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例2：\n输入: nums = [0] 输出: [0] 提示：\n 1 \u0026lt;= nums.length \u0026lt;= 10^4^ -2^31^ \u0026lt;= nums[i] \u0026lt;= 2^31^ - 1  解 fast指针遍历\nfast指针位置不为0时，把fast位置的元素赋值给slow位置\nfast指针为0时，代表数组中有一个0元素\n将slow-\u0026gt;结尾的元素赋值0\nclass Solution { public void moveZeroes(int[] nums) { int slow = 0; int n = nums.length; for (int fast = 0; fast \u0026lt; nums.length; fast++) { if (nums[fast] != 0) { nums[slow] = nums[fast]; slow++; } } for (int i = slow;i \u0026lt; nums.length;i++){ nums[i] = 0; } } } 官方——交换 right指针遍历\nright指针位置不为0时，把right位置的元素和left位置元素交换\n就不用用0覆盖右边元素\nclass Solution { public void moveZeroes(int[] nums) { int n = nums.length, left = 0, right = 0; while (right \u0026lt; n) { if (nums[right] != 0) { swap(nums, left, right); left++; } right++; } } public void swap(int[] nums, int left, int right) { int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; } } ","permalink":"https://lyrace.github.io/post/leetcode283/","summary":"283.移动零 题目链接\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例1：\n输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例2：\n输入: nums = [0] 输出: [0] 提示：\n 1 \u0026lt;= nums.length \u0026lt;= 10^4^ -2^31^ \u0026lt;= nums[i] \u0026lt;= 2^31^ - 1  解 fast指针遍历\nfast指针位置不为0时，把fast位置的元素赋值给slow位置\nfast指针为0时，代表数组中有一个0元素\n将slow-\u0026gt;结尾的元素赋值0\nclass Solution { public void moveZeroes(int[] nums) { int slow = 0; int n = nums.length; for (int fast = 0; fast \u0026lt; nums.length; fast++) { if (nums[fast] !","title":"【Leetcode】283.移动零"},{"content":"接口 一、基本介绍 接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来\ninterface 接口名{\n​\t//属性\n​\t//方法：抽象方法、默认实现方法或静态方法\n}\nclass 类名 implements 接口{\n​\t// 自己的属性\n​\t// 自己的方法\n​\t// 必须实现的接口的抽象方法\n}\njdk7前，接口的所有方法都没有方法体，即都是抽象方法；jdK8后接口可以有静态方法，默认方法，即接口中可以有方法的具体实现\npublic interface Inter { // 属性  public int n1 = 10; // 方法  // 接口中抽象方法可以省略abstract  public void hi(); // jdk8后，可以有默认实现方法，使用default关键字实现  default public void ok(){ System.out.println(\u0026#34;ok...\u0026#34;); } // jdk8后，可以有静态方法  public static void cry(){ System.out.println(\u0026#34;cry..\u0026#34;); } } // 类实现一个接口，需要将该接口的所有抽象方法都实现 class A implements Inter{ @Override public void hi() { System.out.println(\u0026#34;hi..\u0026#34;); } } 二、例 3个程序员，编写3个类，分别完成对MySQL、Oracle、DB2数据库的connect、close\npublic interface DBInterface { void connect(); // 连接  void close(); // 关闭连接 } public class MySQLDB implements DBInterface{ @Override public void connect() { System.out.println(\u0026#34;连接MySQL\u0026#34;); } @Override public void close() { System.out.println(\u0026#34;关闭MySQL\u0026#34;); } } public class OracleDB implements DBInterface{ @Override public void connect() { System.out.println(\u0026#34;Oracle连接\u0026#34;); } @Override public void close() { System.out.println(\u0026#34;Oracle关闭\u0026#34;); } } public class Interface02 { public static void main(String[] args) { MySQLDB mySQLDB = new MySQLDB(); test(mySQLDB); OracleDB oracleDB = new OracleDB(); test(oracleDB); } public static void test(DBInterface dbInterface){ dbInterface.connect(); dbInterface.close(); } } 三、注意事项  接口不能被实例化 接口中所有的方法是public，抽象方法，可以不用abstract修饰   一个普通类实现接口，必须将该接口的所有方法都实现\n普通类alt+enter提示待实现方法\n  抽象类实现接口，可以不实现接口的抽象方法\n  interface IA{ public abstract void say(); public abstract void hi(); } abstract class T implements IA{ } 一个类可以同时实现多个接口  interface IB{ void hi(); } interface IC{ void say(); } // 一个类可以同时实现多个接口 class P implements IB,IA{ @Override public void say() { } @Override public void hi() { } }  接口中的属性只能是final，且是public static final（必须初始化）\n  接口中属性的访问形式：接口名.属性名\n  接口不能继承其它的类，但是可以继承多个别的接口\n  interface ID extends IC,IB{ } 接口的修饰符只能是public和默认的，和类的修饰符一样  四、接口和继承比较 子类继承了父类，就自动拥有父类的功能；如果子类需要扩展功能，可以通过实现接口的方式扩展\n可以理解为实现接口是对java单继承机制的一种补充\npublic class ExtendsVsInterface { public static void main(String[] args) { LittleMonkey littleMonkey = new LittleMonkey(\u0026#34;悟空\u0026#34;); littleMonkey.climb(); littleMonkey.swimming(); } } interface Fish{ void swimming(); } class Monkey{ private String name; public void climb(){ System.out.println(name + \u0026#34;爬树\u0026#34;); } public Monkey(String name) { this.name = name; } public String getName() { return name; } public void setName(String name) { this.name = name; } } class LittleMonkey extends Monkey implements Fish{ public LittleMonkey(String name) { super(name); } @Override public void swimming() { System.out.println(getName()+\u0026#34;通过学习会游泳\u0026#34;); } }   解决问题\n继承：代码复用和可维护性\n接口：设计好方法，让其他类实现\n  接口比继承灵活，继承满足is-a的关系，接口满足like-a关系\n  接口一定程度上实现代码解耦[接口规范性+动态绑定]\n  五、接口的多态特性   多态参数\n接口引用可以指向实现了接口的类的对象\n  public class InterfacePolyParameter { public static void main(String[] args) { // 接口类型的变量可以指向实现了IF接口的对象实例  IF if01 = new M(); if01 = new Ca(); } } interface IF{} class M implements IF{} class Ca implements IF{} 多态数组  public class InterfacePolyArr { public static void main(String[] args) { // 多态数组 接口类型数组  Usb[] usbs = new Usb[2]; usbs[0] = new Phone(); usbs[1] = new Camera(); for (int i = 0; i \u0026lt; usbs.length; i++) { usbs[i].work(); // 向下转型  // instanceof判断运行类型  if(usbs[i] instanceof Phone){ ((Phone)usbs[i]).call(); } } } } interface Usb{ void work(); } class Phone implements Usb{ public void call(){ System.out.println(\u0026#34;打电话\u0026#34;); } @Override public void work() { System.out.println(\u0026#34;手机工作中\u0026#34;); } } class Camera implements Usb{ @Override public void work() { System.out.println(\u0026#34;相机工作中\u0026#34;); } } 多态传递  public class InterfacePolyPass { public static void main(String[] args) { IG ig = new Te(); //如果 IG 继承了 IH 接口，而 Te 类实现了 IG 接口  //实际上就相当于 Te 类也实现了 IH 接口  IH ih = new Te(); } } interface IH{} interface IG extends IH{} class Te implements IG{} ","permalink":"https://lyrace.github.io/post/java17/","summary":"接口 一、基本介绍 接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，再根据具体情况把这些方法写出来\ninterface 接口名{\n​\t//属性\n​\t//方法：抽象方法、默认实现方法或静态方法\n}\nclass 类名 implements 接口{\n​\t// 自己的属性\n​\t// 自己的方法\n​\t// 必须实现的接口的抽象方法\n}\njdk7前，接口的所有方法都没有方法体，即都是抽象方法；jdK8后接口可以有静态方法，默认方法，即接口中可以有方法的具体实现\npublic interface Inter { // 属性  public int n1 = 10; // 方法  // 接口中抽象方法可以省略abstract  public void hi(); // jdk8后，可以有默认实现方法，使用default关键字实现  default public void ok(){ System.out.println(\u0026#34;ok...\u0026#34;); } // jdk8后，可以有静态方法  public static void cry(){ System.out.println(\u0026#34;cry..\u0026#34;); } } // 类实现一个接口，需要将该接口的所有抽象方法都实现 class A implements Inter{ @Override public void hi() { System.","title":"【Java笔记】17.接口"},{"content":"抽象类 一、介绍   当父类的某些方法需要声明，但又不确定如何实现时，将其声明为抽象方法，这个类就是抽象类\n  用abstract关键字修饰一个类时，这个类就叫抽象类\n访问修饰符 abstract 类名{}\n  用abstract关键字来修饰一个方法时，这个方法就是抽象方法\n访问修饰符 abstract 返回类型 方法名（参数列表）; // 没有方法体\n  抽象类一般会被继承，其子类来实现抽象方法\n  二、注意事项  抽象类不能被实例化 抽象类不一定要包含abstract方法，即抽象类可以没有abstract方法，可以有实现的方法 一旦类包含了abstract方法，则这个类必须声明为abstract abstract只能修饰类和方法，不能修饰属性和其它的 抽象类可以有任意成员，比如非抽象方法、构造器、静态属性.. 抽象方法不能有主体，即不能实现 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背  public class Abstract01 { } abstract class H{ public abstract void hi(); // 抽象方法 } // 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类 abstract class E{ public abstract void hi(); } abstract class F extends E{ } class G extends E{ @Override public void hi() { // 实现方法，有方法体就行  } } 三、抽象类实践——模板设计模式 3.1 基本介绍 ​\t抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式，\n3.2 模板设计模式能解决的问题  当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类实现 编写一个抽象父类，父类提供了多个子类的通用方法，并把一个或多个方法留给子类实现，就是一种模板模式  3.3 例 需求：\n 有多个类，完成不同的任务job 要求统计得到各自完成任务的时间  abstract public class Template { public abstract void job(); // 抽象方法  // 实现方法，调用job方法  public void calculateTime(){ // 得到开始的时间  long start = System.currentTimeMillis(); job(); // 动态绑定  // 得到结束的时间  long end = System.currentTimeMillis(); System.out.println(\u0026#34;任务执行时间 \u0026#34;+(end-start)); } } public class AA extends Template{ @Override public void job() { long num = 0; for (int i = 1; i \u0026lt;= 80000000; i++) { num+=i; } } } public class BB extends Template{ @Override public void job() { long num = 0; for (long i = 1; i \u0026lt;= 80000; i++) { num *= i; } } } public class Test { public static void main(String[] args) { AA aa = new AA(); aa.calculateTime(); BB bb = new BB(); bb.calculateTime(); } } ","permalink":"https://lyrace.github.io/post/java16/","summary":"抽象类 一、介绍   当父类的某些方法需要声明，但又不确定如何实现时，将其声明为抽象方法，这个类就是抽象类\n  用abstract关键字修饰一个类时，这个类就叫抽象类\n访问修饰符 abstract 类名{}\n  用abstract关键字来修饰一个方法时，这个方法就是抽象方法\n访问修饰符 abstract 返回类型 方法名（参数列表）; // 没有方法体\n  抽象类一般会被继承，其子类来实现抽象方法\n  二、注意事项  抽象类不能被实例化 抽象类不一定要包含abstract方法，即抽象类可以没有abstract方法，可以有实现的方法 一旦类包含了abstract方法，则这个类必须声明为abstract abstract只能修饰类和方法，不能修饰属性和其它的 抽象类可以有任意成员，比如非抽象方法、构造器、静态属性.. 抽象方法不能有主体，即不能实现 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背  public class Abstract01 { } abstract class H{ public abstract void hi(); // 抽象方法 } // 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类 abstract class E{ public abstract void hi(); } abstract class F extends E{ } class G extends E{ @Override public void hi() { // 实现方法，有方法体就行  } } 三、抽象类实践——模板设计模式 3.","title":"【Java笔记】16.抽象类"},{"content":"26.删除有序数组中的重复项 题目链接\n给你一个升序排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序应该保持 一致 。\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n不要使用额外的空间，你必须在原地修改输入数组 并在使用O(1)额外空间的条件下完成。\n判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } 示例1：\n输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例2：\n输入：nums = [0,0,1,1,1,2,2,3,3,4] 输出：5, nums = [0,1,2,3,4] 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 提示：\n  0 \u0026lt;= nums.length \u0026lt;= 3 * 104\n  -104 \u0026lt;= nums[i] \u0026lt;= 104\n  nums 已按 升序 排列\n  双指针 快慢指针 数组没有元素时-\u0026gt;返回0 数组元素数n大于0时，定义快指针fast代表遍历到的元素位置、慢指针slow表示待赋值的元素位置\tfast=slow=1\n nums[fast]=nums[fast-1]时，fast右移 nums[fast]!=nums[fast-1]时，fast位置的元素赋给slow位置，slow、fast右移  class Solution { public int removeDuplicates(int[] nums) { int n = nums.length; if(n == 0){ return 0; } int fast = 1, slow = 1; while(fast \u0026lt; n){ if(nums[fast-1] != nums[fast]){ nums[slow] = nums[fast]; slow++; } fast++; } return slow; } } ","permalink":"https://lyrace.github.io/post/leetcode26/","summary":"26.删除有序数组中的重复项 题目链接\n给你一个升序排列的数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。元素的相对顺序应该保持 一致 。\n由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。\n将最终结果插入 nums 的前 k 个位置后返回 k 。\n不要使用额外的空间，你必须在原地修改输入数组 并在使用O(1)额外空间的条件下完成。\n判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组 int[] expectedNums = [...]; // 长度正确的期望答案 int k = removeDuplicates(nums); // 调用 assert k == expectedNums.length; for (int i = 0; i \u0026lt; k; i++) { assert nums[i] == expectedNums[i]; } 示例1：\n输入：nums = [1,1,2] 输出：2, nums = [1,2,_] 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 示例2：","title":"【Leetcode】26删除有序数组中的重复项"},{"content":"final 一、介绍 final可以修饰类、属性、方法和局部变量\n使用final:\n  不希望类被继承时\nfinal class A{} // class B extends A{} 此时A类不能被继承   不希望父类的某个方法被子类覆盖/重写时\nclass C{ // 要求hi不能被子类重写，可以使用final修饰hi方法  public final void hi(){} } class D extends C{ //此时不能重写hi()方法 // @Override // public void hi(){ // System.out.println(\u0026#34;重写\u0026#34;); // } }   不希望类的某个属性的值被修改\npublic class final_ { public static void main(String[] args) { E e = new E(); // e.TAX_RATE = 0.09; 此时不能更改  } } class E{ public final double TAX_RATE = 0.08; }   不希望某个局部变量被修改\nclass F{ public void cry(){ final double NUM = 0.01; //NUM不能更改  } }   二、注意事项   final修饰的属性又叫常量，一般用XXX_XX_XXX来命名\n  final修饰的属性在定义时，必须赋初值，且以后不能再修改，赋值可以在：\n 定义时 在构造器中 在代码块中  class AA{ public final double TAX_RATE = 0.1;// 1. 在定义时  public final double TAX_RATE1; public final double TAX_RATE2; // 2. 在构造器中赋值  public AA(){ TAX_RATE1 = 0.2; } // 3. 在代码块赋值  { TAX_RATE2 = 0.3; } }   如果final修饰的属性是静态的，则初始化的位置\n  定义时\n  在静态代码块\n  class BB{ public static final double TAX_RATE3 = 0.3; // 1. 定义时  public static final double TAX_RATE4; // 2. 在静态代码块中  static { TAX_RATE4 = 0.4; } }   final类不能继承，但可以实例化对象\n  如果类不是final类，但含有final方法，则该方法虽然不能重写，但可以被继承\nclass DD{ public final void cal(){ System.out.println(\u0026#34;cal()方法\u0026#34;); } } class EE extends DD{}   一般来说，如果一个类已经时final类了，就没有必要再将方法修饰成final方法\n  final不能修饰构造方法（即构造器）\n  final和static往往搭配使用，效率更高，不会导致类加载，底层编译器做了优化处理\npublic class FinalDetail02 { public static void main(String[] args) { System.out.println(BBB.num); } } class BBB{ public final static int num = 1000; static { System.out.println(\u0026#34;BBB静态代码块被执行\u0026#34;); } }  1000\n\u0026ldquo;BBB静态代码块被执行\u0026quot;不会输出，类没有加载\n   包装类（Integer,Double,Float,Boolean等都是final），String也是。\n  ","permalink":"https://lyrace.github.io/post/java15/","summary":"final 一、介绍 final可以修饰类、属性、方法和局部变量\n使用final:\n  不希望类被继承时\nfinal class A{} // class B extends A{} 此时A类不能被继承   不希望父类的某个方法被子类覆盖/重写时\nclass C{ // 要求hi不能被子类重写，可以使用final修饰hi方法  public final void hi(){} } class D extends C{ //此时不能重写hi()方法 // @Override // public void hi(){ // System.out.println(\u0026#34;重写\u0026#34;); // } }   不希望类的某个属性的值被修改\npublic class final_ { public static void main(String[] args) { E e = new E(); // e.TAX_RATE = 0.09; 此时不能更改  } } class E{ public final double TAX_RATE = 0.","title":"【Java笔记】15.final"},{"content":"单例设计模式 一、什么是单例设计模式  采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法 两种方式：饿汉式和懒汉式  二、饿汉式 类加载时创建，不存在线程安全问题\n  构造器私有化，防止直接new\n  类的内部创建对象 static\n  向外暴露一个静态的公共方法\n  饿汉式可能造成创建了对象但是没有使用\npublic class SingleTon01 { public static void main(String[] args) { A a = A.getInstance(); //通过方法获取对象  } } class A{ private String name; // 2. 在类的内部直接创建,此时外部不可用  private static A a = new A(\u0026#34;aaa\u0026#34;); // 保证只能创建一个对象  // 1. 将构造器私有化  private A(String name){ this.name = name; } // 3. 提供一个公共的static方法，返回对象  // 设为静态才能保证不创建对象能直接调用这个方法，因此2中的对象是static的  public static A getInstance(){ return a; } } 三、懒汉式 懒汉式只有当用户使用getInstance()时，才能返回对象，再次调用时，会返回上次创建的cat对象，存在线程安全问题\npublic class SingleTon02 { public static void main(String[] args) { Cat instance = Cat.getInstance(); } } // 希望在程序运行过程中，只能创建一个Cat对象 class Cat{ private String name; // 2.定义一个static静态属性对象  private static Cat cat; // 1. 构造器私有化  private Cat(String name){ this.name = name; } // 3. 提供一个public的static方法，可以返回一个Cat对象  public static Cat getInstance() { if(cat == null) { cat = new Cat(\u0026#34;aaa\u0026#34;); } return cat; } } 四、实例 Runtime工具类的源码\npublic class Runtime { private static Runtime currentRuntime = new Runtime(); /** * Returns the runtime object associated with the current Java application. * Most of the methods of class \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; are instance * methods and must be invoked with respect to the current runtime object. * * @return the \u0026lt;code\u0026gt;Runtime\u0026lt;/code\u0026gt; object associated with the current * Java application. */ public static Runtime getRuntime() { return currentRuntime; } /** Don\u0026#39;t let anyone else instantiate this class */ private Runtime() {} ","permalink":"https://lyrace.github.io/post/java14/","summary":"单例设计模式 一、什么是单例设计模式  采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法 两种方式：饿汉式和懒汉式  二、饿汉式 类加载时创建，不存在线程安全问题\n  构造器私有化，防止直接new\n  类的内部创建对象 static\n  向外暴露一个静态的公共方法\n  饿汉式可能造成创建了对象但是没有使用\npublic class SingleTon01 { public static void main(String[] args) { A a = A.getInstance(); //通过方法获取对象  } } class A{ private String name; // 2. 在类的内部直接创建,此时外部不可用  private static A a = new A(\u0026#34;aaa\u0026#34;); // 保证只能创建一个对象  // 1. 将构造器私有化  private A(String name){ this.name = name; } // 3.","title":"【Java笔记】14.单例设计模式"},{"content":"27.移除元素 题目链接\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例1：\n输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例2：\n输入：nums = [0,1,2,2,3,0,4,2], val = 2 输出：5, nums = [0,1,4,0,3] 解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。 提示：\n 0 \u0026lt;= nums.length \u0026lt;= 100 0 \u0026lt;= nums[i] \u0026lt;= 50 0 \u0026lt;= val \u0026lt;= 100  暴力解一 外层循环判断是否与val相同，内层循环进行数组元素的移动\nclass Solution { public int removeElement(int[] nums, int val) { int length = nums.length; for(int i = 0; i \u0026lt; nums.length; ){ if(nums[i] == val){ for(int j = i; j \u0026lt; length - 1; j++){ nums[j] = nums[j + 1]; } nums[length - 1] = -1; //0 \u0026lt;= nums[i] \u0026lt;= 50，保证数组后面无效元素不与val相同  length--; }else{ i++; } } return length; } } 暴力解二 class Solution { public int removeElement(int[] nums, int val) { int length = nums.length; for(int i = 0; i \u0026lt; length; i++){ if(nums[i] == val) { for (int j = i + 1; j \u0026lt; length; j++) { nums[j - 1] = nums[j]; } length--; i--; } } return length; } } 双指针 双指针，右指针指向待处理（下一个要判断是否等于val）的元素，左指针指向待赋值的元素，即左指针指向等于val的元素\n 右指针指向的元素不等于val时，其指向的元素可以保留，将右指针指向的元素赋给左指针，左右指针右移 右指针指向的元素等于val时，其指向的元素不可以保留，则左指针不动，右指针右移  左指针指向的位置就是输出的数组长度\nclass Solution { public int removeElement(int[] nums, int val) { int left = 0; for(int right = 0; right \u0026lt; nums.length; right++){ if(nums[right] != val){ nums[left] = nums[right]; left++; } } return left; } } 双指针二 左指针放在数组头，右指针放在数组尾，当left \u0026lt;= right时，\n 如果左指针指向的元素等于val，将右指针指向的元素赋值给左指针指向的位置，右指针左移一位 如果左指针指向的元素不等于val，左指针右移一位 左指针就是数组的长度。  class Solution { public int removeElement(int[] nums, int val) { int left = 0; int right = nums.length - 1; while (left \u0026lt;= right){ if (nums[left] == val) { nums[left] = nums[right]; right--; } else { left++; } } return left; } } ","permalink":"https://lyrace.github.io/post/leetcode27/","summary":"27.移除元素 题目链接\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝 int len = removeElement(nums, val); // 在函数里修改输入数组对于调用者是可见的。 // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for (int i = 0; i \u0026lt; len; i++) { print(nums[i]); } 示例1：\n输入：nums = [3,2,2,3], val = 3 输出：2, nums = [2,2] 解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。 示例2：","title":"【Leetcode】27.移除元素"},{"content":"代码块 一、基本介绍 代码化块又称为初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。\n但没有方法名，没有返回，没有参数，只有方法体，且不用通过对象或类显式调用，而是==加载类时==，创建对象时隐式调用。\n二、基本语法 1.语法 [修饰符]{\n​\t代码\n};\n 修饰符可选，但写的话只能写static 代码块分两类，使用static修饰的交静态代码块，没有static修饰的，叫普通代码块/非静态代码块。 逻辑语句可以为任何逻辑语句 输入、输出、方法调用、循环、判断等 ;可以写，也可以省略  2.用处 如果多个构造器中都有重复的语句，可以抽取到初始化块中。\npublic class CodeBlock01 { public static void main(String[] args) { Movie movie = new Movie(\u0026#34;xxx电影\u0026#34;); System.out.println(\u0026#34;-----------\u0026#34;); new Movie(\u0026#34;电影\u0026#34;,50,\u0026#34;xx\u0026#34;); } } class Movie{ private String name; private double price; private String director; // 把三个构造器的相同语句放入一个代码块中  // 不管调用那个构造器，创建对象，都会先调用代码块的内容  // 代码块调用的顺序优先于构造器  { System.out.println(\u0026#34;屏幕打开..\u0026#34;); System.out.println(\u0026#34;广告开始..\u0026#34;); System.out.println(\u0026#34;电影开始..\u0026#34;); } public Movie(String name){ System.out.println(\u0026#34;Movie(String name)被调用\u0026#34;); this.name = name; } public Movie(String name,double price){ System.out.println(\u0026#34;Movie(String name,double price)被调用\u0026#34;); this.name = name; this.price = price; } public Movie(String name,double price,String director){ System.out.println(\u0026#34;Movie(String name,double price,String director)被调用\u0026#34;); this.name = name; this.price = price; this.director = director; } }  输出：\n屏幕打开.. 广告开始.. 电影开始.. Movie(String name)被调用\n 屏幕打开.. 广告开始.. 电影开始.. Movie(String name,double price,String director)被调用\n 3.注意事项   static代码块也叫静态代码块，对类进行初始化，随着类的加载而执行，并且只会执行一次\n普通代码块，每创建一个对象，就执行\n  类什么时候被加载\n（1）创建对象实例时（new）\npublic class CodeBlockDetail { public static void main(String[] args) { A a = new A(); } } class A { static { System.out.println(\u0026#34;A的静态代码被执行\u0026#34;); } }  A的静态代码被执行\n （2）创建子类对象实例，父类也会被加载\npublic class CodeBlockDetail { public static void main(String[] args) { // 父类先被加载，子类后被加载  A a = new A(); } } class B{ static { System.out.println(\u0026#34;B的静态代码被执行\u0026#34;); } } class A extends B { static { System.out.println(\u0026#34;A的静态代码被执行\u0026#34;); } }  B的静态代码被执行 A的静态代码被执行\n （3）使用类的静态成员时（静态属性，静态方法）\npublic class CodeBlockDetail01 { public static void main(String[] args) { System.out.println(Cat.n1); } } class Animal{ static { System.out.println(\u0026#34;Animal的静态代码被执行\u0026#34;); } } class Cat extends Animal{ public static int n1 = 10; static { System.out.println(\u0026#34;Cat的静态代码被执行\u0026#34;); } }  Animal的静态代码被执行 Cat的静态代码被执行 10\n   普通的代码块，在创建对象实例时，会被隐式的调用\n被创建一次，就会调用一次\n如果知识使用类的静态成员时，普通代码块并不会执行\n  public class CodeBlockDetail01 { public static void main(String[] args) { // static代码块，在类加载时，执行的，而且只会执行一次  // 普通的代码块，在创建对象实例时会被隐式调用  // 被创建一次，就会调用一次  D d = new D(); D d1 = new D(); // 如果只是使用类的静态成员时，普通代码块并不会执行  System.out.println(D.n); } } class D{ public static int n = 10; // 静态属性  // 静态代码块  static { System.out.println(\u0026#34;D的静态代码被执行\u0026#34;); } // 普通代码块，在new对象时被调用，每创建一个对象，就调用一次  { System.out.println(\u0026#34;D的普通代码块\u0026#34;); } }  D的静态代码被执行 D的普通代码块 D的普通代码块 10\n  创建一个对象时，在一个类调用顺序是：\n（1）调用静态代码块和静态属性初始化\n​\t静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，按定义的顺序调用。\n（2）调用普通代码块和普通属性的初始化\n​\t普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，按定义顺序调用\n（3）调用构造方法\npublic class CodeBlockDetail02 { public static void main(String[] args) { AA aa = new AA(); } } class AA{ // 普通代码块  { System.out.println(\u0026#34;AA的普通代码块\u0026#34;); } private int n2 = getN2(); // 普通属性的初始化  // 静态代码块  static { System.out.println(\u0026#34;AA的静态代码块\u0026#34;); } // 静态属性的初始化  private static int n1 = getN1(); // 静态属性初始化  public static int getN1(){ System.out.println(\u0026#34;getN1被调用\u0026#34;); return 100; } public int getN2(){ System.out.println(\u0026#34;getN2被调用\u0026#34;); return 200; } public AA(){ System.out.println(\u0026#34;AA()构造器被调用\u0026#34;); } }  AA的静态代码块 getN1被调用 AA的普通代码块 getN2被调用 AA()构造器被调用\n   构造器的最前面隐含了super()和调用普通代码块，静态相关的代码块，属性初始化在类加载时就执行完毕，因此优先于构造器和普通代码块执行\n  public class CodeBlockDetail03 { public static void main(String[] args) { new BBB(); } } class AAA{ { System.out.println(\u0026#34;AAA的普通代码块\u0026#34;); } public AAA(){ //1.super()  //2.调用本类的普通代码块  System.out.println(\u0026#34;AAA()构造器被调用\u0026#34;); } } class BBB extends AAA{ { System.out.println(\u0026#34;BBB的普通代码块\u0026#34;); } public BBB(){ //1.super()  //2.调用本类的普通代码块  System.out.println(\u0026#34;BBB()构造器被调用\u0026#34;); } }  AAA的普通代码块 AAA()构造器被调用 BBB的普通代码块 BBB()构造器被调用\n  创建一个子类对象时，顺序：\n（1）父类的静态代码块和静态属性（优先级一样，按定义顺序）\n（2）子类的静态代码块和静态属性（优先级一样，按定义顺序）\n（3）父类的普通代码块和普通属性初始化（优先级一样，按定义顺序）\n（4）父类的构造方法\n（5）子类的普通代码块和普通属性初始化（优先级一样，按定义顺序）\n（6）子类的构造方法\n  静态代码块只能直接调用静态成员，普通代码块可以调用任意成员。\n  ","permalink":"https://lyrace.github.io/post/java13/","summary":"代码块 一、基本介绍 代码化块又称为初始化块，属于类中的成员，类似于方法，将逻辑语句封装在方法体中，通过{}包围起来。\n但没有方法名，没有返回，没有参数，只有方法体，且不用通过对象或类显式调用，而是==加载类时==，创建对象时隐式调用。\n二、基本语法 1.语法 [修饰符]{\n​\t代码\n};\n 修饰符可选，但写的话只能写static 代码块分两类，使用static修饰的交静态代码块，没有static修饰的，叫普通代码块/非静态代码块。 逻辑语句可以为任何逻辑语句 输入、输出、方法调用、循环、判断等 ;可以写，也可以省略  2.用处 如果多个构造器中都有重复的语句，可以抽取到初始化块中。\npublic class CodeBlock01 { public static void main(String[] args) { Movie movie = new Movie(\u0026#34;xxx电影\u0026#34;); System.out.println(\u0026#34;-----------\u0026#34;); new Movie(\u0026#34;电影\u0026#34;,50,\u0026#34;xx\u0026#34;); } } class Movie{ private String name; private double price; private String director; // 把三个构造器的相同语句放入一个代码块中  // 不管调用那个构造器，创建对象，都会先调用代码块的内容  // 代码块调用的顺序优先于构造器  { System.out.println(\u0026#34;屏幕打开..\u0026#34;); System.out.println(\u0026#34;广告开始..\u0026#34;); System.out.println(\u0026#34;电影开始..\u0026#34;); } public Movie(String name){ System.out.println(\u0026#34;Movie(String name)被调用\u0026#34;); this.name = name; } public Movie(String name,double price){ System.","title":"【Java笔记】13.代码块"},{"content":"main public static void main(String[] args){}\n  main方法由虚拟机调用\n  java虚拟机需要调用类的main()方法，该方法的访问权限必须是public\n  java虚拟机在执行main()方法时不必创建对象\u0026ndash;\u0026gt;该方法必须是static\n  该方法接收String类型的数组参数，该数组保存执行java命令时传递给所运行的类的参数\n  cmd中java 执行的程序 参数1 参数2 参数3\u0026hellip; e.g.:java HelloWorld n1 n2 n3\nargs数组 第一个参数为n1 第二个参数为n2 第三个参数为n3\nIDEA中传参数\n  main()方法中，可以直接调用main方法所在类的静态方法或静态属性，但不能访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象访问类中的非静态成员\n  ","permalink":"https://lyrace.github.io/post/java12/","summary":"main public static void main(String[] args){}\n  main方法由虚拟机调用\n  java虚拟机需要调用类的main()方法，该方法的访问权限必须是public\n  java虚拟机在执行main()方法时不必创建对象\u0026ndash;\u0026gt;该方法必须是static\n  该方法接收String类型的数组参数，该数组保存执行java命令时传递给所运行的类的参数\n  cmd中java 执行的程序 参数1 参数2 参数3\u0026hellip; e.g.:java HelloWorld n1 n2 n3\nargs数组 第一个参数为n1 第二个参数为n2 第三个参数为n3\nIDEA中传参数\n  main()方法中，可以直接调用main方法所在类的静态方法或静态属性，但不能访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象访问类中的非静态成员\n  ","title":"【Java笔记】12.main"},{"content":"367.有效的完全平方数 题目链接\n给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n进阶：不要 使用任何内置的库函数，如 sqrt 。\n示例1：\n输入：num = 16 输出：true 示例2：\n输入：num = 14 输出：false 提示：\n 1 \u0026lt;= num \u0026lt;= 2^31^ - 1  二分查找 class Solution { public boolean isPerfectSquare(int num) { int left = 1; int right = num; int mid = left + (right - left) / 2; while(left \u0026lt;= right){ if((long)mid * mid == num){ return true; }else if((long)mid * mid \u0026lt; num){ left = mid + 1; }else{ right = mid -1; } mid = left + (right - left) / 2; } return false; } }  乘法可能会越界，强转一下\n 内置库函数 class Solution { public boolean isPerfectSquare(int num) { int x = (int) Math.sqrt(num); return x * x == num; } } 牛顿迭代法 ","permalink":"https://lyrace.github.io/post/leetcode367/","summary":"367.有效的完全平方数 题目链接\n给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n进阶：不要 使用任何内置的库函数，如 sqrt 。\n示例1：\n输入：num = 16 输出：true 示例2：\n输入：num = 14 输出：false 提示：\n 1 \u0026lt;= num \u0026lt;= 2^31^ - 1  二分查找 class Solution { public boolean isPerfectSquare(int num) { int left = 1; int right = num; int mid = left + (right - left) / 2; while(left \u0026lt;= right){ if((long)mid * mid == num){ return true; }else if((long)mid * mid \u0026lt; num){ left = mid + 1; }else{ right = mid -1; } mid = left + (right - left) / 2; } return false; } }  乘法可能会越界，强转一下","title":"【Leetcode】367.有效的完全平方数"},{"content":"69.x的平方根 题目链接\n给你一个非负整数 x ，计算并返回 x 的算术平方根 。\n由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例1：\n输入：x = 4 输出：2 示例2：\n输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示：\n 0 \u0026lt;= x \u0026lt;= 2 ^31^ - 1  二分查找 class Solution { public int mySqrt(int x) { int left = 1; int right = x; int mid = x / 2; while(left \u0026lt;= right){ if(mid * mid == x){ // 算数平方根是整数的  return mid; } // 乘法超出int范围-\u0026gt;long  else if((long)mid * mid \u0026lt; x){ // mid * mid 比 x 小  if((long)(mid + 1) * (mid + 1) \u0026gt; x){ // mid * mid 比 x 小且(mid + 1) * (mid + 1)比 x 大  return mid; }else if((long)(mid + 1) * (mid + 1) == x) { // mid * mid 比 x 小且(mid + 1) * (mid + 1)等于x  return mid + 1; }else{ // 否则查找范围在右半边  left = mid + 1; } }else if((long)mid * mid \u0026gt; x){ // 查找范围在左半边  right = mid - 1; } mid = left + (right - left) / 2; } return 0; } }  官方题解  class Solution { public int mySqrt(int x) { int l = 0, r = x, ans = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } } 牛顿迭代法 ","permalink":"https://lyrace.github.io/post/leetcode69/","summary":"69.x的平方根 题目链接\n给你一个非负整数 x ，计算并返回 x 的算术平方根 。\n由于返回类型是整数，结果只保留整数部分 ，小数部分将被舍去 。\n注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例1：\n输入：x = 4 输出：2 示例2：\n输入：x = 8 输出：2 解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示：\n 0 \u0026lt;= x \u0026lt;= 2 ^31^ - 1  二分查找 class Solution { public int mySqrt(int x) { int left = 1; int right = x; int mid = x / 2; while(left \u0026lt;= right){ if(mid * mid == x){ // 算数平方根是整数的  return mid; } // 乘法超出int范围-\u0026gt;long  else if((long)mid * mid \u0026lt; x){ // mid * mid 比 x 小  if((long)(mid + 1) * (mid + 1) \u0026gt; x){ // mid * mid 比 x 小且(mid + 1) * (mid + 1)比 x 大  return mid; }else if((long)(mid + 1) * (mid + 1) == x) { // mid * mid 比 x 小且(mid + 1) * (mid + 1)等于x  return mid + 1; }else{ // 否则查找范围在右半边  left = mid + 1; } }else if((long)mid * mid \u0026gt; x){ // 查找范围在左半边  right = mid - 1; } mid = left + (right - left) / 2; } return 0; } }  官方题解  class Solution { public int mySqrt(int x) { int l = 0, r = x, ans = -1; while (l \u0026lt;= r) { int mid = l + (r - l) / 2; if ((long) mid * mid \u0026lt;= x) { ans = mid; l = mid + 1; } else { r = mid - 1; } } return ans; } } 牛顿迭代法 ","title":"【LeetCode】69.x的平方根(未完)"},{"content":"类变量和类方法 一、类变量 1.1 什么是类变量 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象访问时，取到的都是相同值，任何一个该类的对象去修改时，修改的也是同一个变量。\n1.2 定义类变量 访问修饰符 static 数据类型 变量名；[推荐]\nstatic 访问修饰符 数据类型 变量名；\n1.3 访问类变量 类名.类变量名 或 对象名.类变量名\n静态变量的访问修饰符的访问权限和范围和普通属性是一样的。\npublic class VisticStatic { public static void main(String[] args) { //类名.类变量名  //类变量随着类的加载而创建，没有创建对象实例也可以访问  System.out.println(A.name); A a = new A(); //对象名.类变量名  System.out.println(\u0026#34;a.name=\u0026#34; + a.name); } } class A{ // 类变量的访问必须遵守访问权限  public static String name = \u0026#34;lll\u0026#34;; // 类变量  private int num = 10; // 普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量 } 1.4 类变量的内存布局 有不同说法 可能由于jdk版本不同 在堆或者静态域\n但 static变量是对象共享，在类加载时就生成了\n1.5 注意事项   什么时候使用类变量 需要让某个类的所有对象共享一个变量时\n  类变量与实例变量（普通属性）区别 类变量是该类的所有对象共享的，实例变量是每个对象独享的。\n  加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量\n  实例变量不能通过类名.类变量名访问\n  类变量的生命周期随类的加载开始，随类消亡而销毁\n  public class StaticDetail { public static void main(String[] args) { B b = new B(); // System.out.println(B.n1);//没static，不能用类名.变量名表示  System.out.println(B.n2); //静态变量是类加载的时候，就创建了,没有创建对象实例也可以通过类名.类变量名来访问  System.out.println(C.address); } } class B{ public int n1 = 100; public static int n2 = 200; } class C{ public static String address = \u0026#34;xxx\u0026#34;; } 二、类方法 2.1 类方法也叫静态方法\n访问修饰符 static 数据返回类型 方法名(){} 【推荐】\nstatic 访问修饰符 数据返回类型 方法名(){}\n2.2 类方法的调用 类名.类方法名 或 对象名.类方法名\npublic class StaticMethod { public static void main(String[] args) { Stu tom = new Stu(\u0026#34;tom\u0026#34;); //tom.payFee(100);或  Stu.payFee(100); Stu mary = new Stu(\u0026#34;mary\u0026#34;); //mary.payFee(200);或  Stu.payFee(200); Stu.showFee(); // 300  } } class Stu { private String name;//普通成员  //静态变量累加学生学费  private static double fee = 0; public Stu(String name) { this.name = name; } //static修饰后，该方法是静态方法，静态方法可以访问静态属性/变量  public static void payFee(double fee) { Stu.fee += fee; } public static void showFee() { System.out.println(\u0026#34;总学费有：\u0026#34; + Stu.fee); } } 2.3 使用场景 方法中不涉及任何和对象相关的成员，如工具类中的方法 Math类，开方 Math.sqrt(9);\n2.4 注意事项 类方法和普通方法都是随类的加载而加载，将结构信息存储在方法区\n类方法中无this的参数，普通方法中隐含着this的参数\n类方法不允许使用和对象有关的关键字，如this和super\n类方法中只能访问静态变量或静态方法，普通成员方法，既可以访问静态成员也可以访问非静态成员（成员即变量和方法）。\n","permalink":"https://lyrace.github.io/post/java11/","summary":"类变量和类方法 一、类变量 1.1 什么是类变量 类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象访问时，取到的都是相同值，任何一个该类的对象去修改时，修改的也是同一个变量。\n1.2 定义类变量 访问修饰符 static 数据类型 变量名；[推荐]\nstatic 访问修饰符 数据类型 变量名；\n1.3 访问类变量 类名.类变量名 或 对象名.类变量名\n静态变量的访问修饰符的访问权限和范围和普通属性是一样的。\npublic class VisticStatic { public static void main(String[] args) { //类名.类变量名  //类变量随着类的加载而创建，没有创建对象实例也可以访问  System.out.println(A.name); A a = new A(); //对象名.类变量名  System.out.println(\u0026#34;a.name=\u0026#34; + a.name); } } class A{ // 类变量的访问必须遵守访问权限  public static String name = \u0026#34;lll\u0026#34;; // 类变量  private int num = 10; // 普通属性/普通成员变量/非静态属性/非静态成员变量/实例变量 } 1.","title":"【Java笔记】11 类变量和类方法"},{"content":"34.在排序数组中查找元素的第一个和最后一个位置 题目链接\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n示例1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例2：\n输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例3：\n输入：nums = [], target = 0 输出：[-1,-1] 提示：\n  0 \u0026lt;= nums.length \u0026lt;= 10^5^\n  -10^9^ \u0026lt;= nums[i] \u0026lt;= 10^9^\n  nums 是一个非递减数组\n  -10^9^ \u0026lt;= target \u0026lt;= 10^9^\n  二分查找 分三种情况讨论，且在二分查找是，nums[mid]==target时仍更新，才能保证取到的是边界值\nclass Solution{ int[] searchRange(int[] nums, int target) { // target的左边界 比target小的那个  int leftBorder = getLeftBorder(nums, target); // target的右边界 比target大的那个  int rightBorder = getRightBorder(nums, target); // 情况一  // target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}  if (leftBorder == -2 || rightBorder == -2) return new int[]{-1, -1}; // 情况三  // target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}  if (rightBorder - leftBorder \u0026gt; 1) return new int[]{leftBorder + 1, rightBorder - 1}; // 情况二  // target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}  return new int[]{-1, -1}; } // 寻找target的右边界  int getRightBorder(int[] nums, int target) { int left = 0; int right = nums.length - 1; int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况  while (left \u0026lt;= right) { int middle = left + ((right - left) / 2); if (nums[middle] \u0026gt; target) { right = middle - 1; } else { // 寻找右边界，nums[middle] == target的时候更新left  left = middle + 1; rightBorder = left; } } return rightBorder; } // 寻找target的左边界  int getLeftBorder(int[] nums, int target) { int left = 0; int right = nums.length - 1; int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况  while (left \u0026lt;= right) { int middle = left + ((right - left) / 2); if (nums[middle] \u0026gt;= target) { // 寻找左边界，nums[middle] == target的时候更新right  right = middle - 1; leftBorder = right; } else { left = middle + 1; } } return leftBorder; } } ","permalink":"https://lyrace.github.io/post/leetcode34/","summary":"34.在排序数组中查找元素的第一个和最后一个位置 题目链接\n给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n示例1：\n输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例2：\n输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例3：\n输入：nums = [], target = 0 输出：[-1,-1] 提示：\n  0 \u0026lt;= nums.length \u0026lt;= 10^5^\n  -10^9^ \u0026lt;= nums[i] \u0026lt;= 10^9^\n  nums 是一个非递减数组\n  -10^9^ \u0026lt;= target \u0026lt;= 10^9^\n  二分查找 分三种情况讨论，且在二分查找是，nums[mid]==target时仍更新，才能保证取到的是边界值\nclass Solution{ int[] searchRange(int[] nums, int target) { // target的左边界 比target小的那个  int leftBorder = getLeftBorder(nums, target); // target的右边界 比target大的那个  int rightBorder = getRightBorder(nums, target); // 情况一  // target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}  if (leftBorder == -2 || rightBorder == -2) return new int[]{-1, -1}; // 情况三  // target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}  if (rightBorder - leftBorder \u0026gt; 1) return new int[]{leftBorder + 1, rightBorder - 1}; // 情况二  // target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}  return new int[]{-1, -1}; } // 寻找target的右边界  int getRightBorder(int[] nums, int target) { int left = 0; int right = nums.","title":"【LeetCode】34. 在排序数组中查找元素的第一个和最后一个位置"},{"content":"35.搜索插入位置 题目链接\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为O(log n)的算法。\n示例1：\n输入: nums = [1,3,5,6], target = 5 输出: 2 示例2：\n输入: nums = [1,3,5,6], target = 2 输出: 1 示例3：\n输入: nums = [1,3,5,6], target = 7 输出: 4 示例4：\n输入: nums = [1,3,5,6], target = 0 输出: 0 示例5：\n输入: nums = [1], target = 0 输出: 0 提示：\n 1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 为无重复元素的升序排列数组 -104 \u0026lt;= target \u0026lt;= 104  二分法 class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid = nums.length / 2; while(left \u0026lt;= right){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ right = mid - 1; }else{ left = mid + 1; } mid = left + (right - left) / 2; } return mid; } } ","permalink":"https://lyrace.github.io/post/leetcode35/","summary":"35.搜索插入位置 题目链接\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为O(log n)的算法。\n示例1：\n输入: nums = [1,3,5,6], target = 5 输出: 2 示例2：\n输入: nums = [1,3,5,6], target = 2 输出: 1 示例3：\n输入: nums = [1,3,5,6], target = 7 输出: 4 示例4：\n输入: nums = [1,3,5,6], target = 0 输出: 0 示例5：\n输入: nums = [1], target = 0 输出: 0 提示：\n 1 \u0026lt;= nums.length \u0026lt;= 104 -104 \u0026lt;= nums[i] \u0026lt;= 104 nums 为无重复元素的升序排列数组 -104 \u0026lt;= target \u0026lt;= 104  二分法 class Solution { public int searchInsert(int[] nums, int target) { int left = 0; int right = nums.","title":"【LeetCode】35.搜索插入位置"},{"content":"704.二分查找 题目链接\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例1：\n输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例2：\n输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。  二分查找 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.length - 1; int mid = nums.length / 2; while(left \u0026lt;= right){ if(nums[mid] == target){ return mid; }else if(nums[mid] \u0026gt; target){ // 目标在nums[mid]左侧  right = mid -1; }else{ // 目标在nums[mid]右侧  left = mid + 1; } mid = (left + right) / 2; // mid = left + (right - left) / 2; 防止溢出  } return -1; } }  mid = (left + right) / 2; \u0026ndash;\u0026gt; mid = left + (right - left) / 2，当left和right很大时，相加可能会溢出，相减不会。  ","permalink":"https://lyrace.github.io/post/leetcode704/","summary":"704.二分查找 题目链接\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例1：\n输入: nums = [-1,0,3,5,9,12], target = 9 输出: 4 解释: 9 出现在 nums 中并且下标为 4 示例2：\n输入: nums = [-1,0,3,5,9,12], target = 2 输出: -1 解释: 2 不存在 nums 中因此返回 -1 提示：\n 你可以假设 nums 中的所有元素是不重复的。 n 将在 [1, 10000]之间。 nums 的每个元素都将在 [-9999, 9999]之间。  二分查找 class Solution { public int search(int[] nums, int target) { int left = 0; int right = nums.","title":"【LeetCode】704.二分查找"},{"content":"4.寻找两个正序数组的中位数 题目链接\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n示例1：\n输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例2：\n输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例3：\n输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例4：\n输入：nums1 = [], nums2 = [1] 输出：1.00000 示例5：\n输入：nums1 = [2], nums2 = [] 输出：2.00000 自己写的，时间复杂度O(m+n)  归并，合成一个数组  class Solution { public double findMedianSortedArrays(int[] nums1, int[] nums2) { int m = nums1.length; int n = nums2.length; int total = m + n; int z = (m + n) / 2; double[] arr = new double[m + n]; int i = 0, j = 0, k = 0; double zhong; // 如果有一个数组长度为0，不进行数组拼接  if (m == 0) { if (total % 2 == 0) { zhong = (nums2[z - 1] + nums2[z]) / 2.0; } else { zhong = nums2[z]; } return zhong; } else if (n == 0) { if (total % 2 == 0) { zhong = (nums1[z - 1] + nums1[z]) / 2.0; } else { zhong = nums1[z]; } return zhong; } else { while ((i \u0026lt; m) \u0026amp;\u0026amp; (j \u0026lt; n)) { if (nums1[i] \u0026lt; nums2[j]) { arr[k] = nums1[i]; k++; i++; } else { arr[k] = nums2[j]; k++; j++; } } if (nums1[m - 1] \u0026lt; nums2[n - 1]) { for (; k \u0026lt; total; k++) { arr[k] = nums2[j]; j++; } } else { for (; k \u0026lt; total; k++) { arr[k] = nums1[i]; i++; } } if (total % 2 == 0) { zhong = (arr[z - 1] + arr[z]) / 2.0; } else { zhong = arr[z]; } return zhong; } } }  不归并，两个指针，将较小指针后移一位，直到中位数位置  二分查找，时间复杂度：O(log(m+n)) 转化成寻找两个有序数组中的第 k 小的数，其中 k为 (m+n)/2 或 (m+n)/2+1\n","permalink":"https://lyrace.github.io/post/leetcode4/","summary":"4.寻找两个正序数组的中位数 题目链接\n给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。\n算法的时间复杂度应该为 O(log (m+n)) 。\n示例1：\n输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例2：\n输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 示例3：\n输入：nums1 = [0,0], nums2 = [0,0] 输出：0.00000 示例4：\n输入：nums1 = [], nums2 = [1] 输出：1.00000 示例5：\n输入：nums1 = [2], nums2 = [] 输出：2.","title":"【LeetCode】4.寻找两个正序数组的中位数（未完）"},{"content":"1.两数之和 题目链接\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例2：\n输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n 2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案  遍历 class Solution { public int[] twoSum(int[] nums, int target) { int[] c = new int[2]; for(int i = 0; i \u0026lt; nums.length; i++) for(int j = i+1; j\u0026lt;nums.length; j++){ if(nums[i] + nums[j] == target){ c[0] = i; c[1] = j; return new int[]{i, j}; } } return new int[0]; } } ","permalink":"https://lyrace.github.io/post/leetcode1/","summary":"1.两数之和 题目链接\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例2：\n输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3：\n输入：nums = [3,3], target = 6 输出：[0,1] 提示：\n 2 \u0026lt;= nums.length \u0026lt;= 104 -109 \u0026lt;= nums[i] \u0026lt;= 109 -109 \u0026lt;= target \u0026lt;= 109 只会存在一个有效答案  遍历 class Solution { public int[] twoSum(int[] nums, int target) { int[] c = new int[2]; for(int i = 0; i \u0026lt; nums.","title":"【LeetCode】1.两数之和（未完）"},{"content":"【Java笔记】10 递归 猴子吃桃 有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个。以后每天猴子都吃其中的一半，然后再多吃一个。当到第10天时，想再吃时，发现只有一个桃子了。问：最初共多少个桃子？\npublic calss Recursion{ public static void main(String[] args){ T t1 = new T(); int day = 0; int peachNum = t1.peach(day); if(peachNum != -1){ System.out.println(\u0026#34;第\u0026#34;+day+\u0026#34;天有\u0026#34;+peachNum+\u0026#34;个桃子\u0026#34;); } } } class T{ /* 1.day=10时 有1个桃子 2.day=9时 有(day10+1)*2=4 3.day=8时 有(day9+1)*2=10 前一天的桃子=(后一天的桃子+1)*2 */ public int peach(int day){ if(day == 10){//第10天，只有1个桃  return 1; }else if(day \u0026gt;= 1\u0026amp;\u0026amp;day \u0026lt;= 9){ return (peach(day+1)+1)*2; }else{ System.out.println(\u0026#34;day在1-10\u0026#34;); return -1; } } } 迷宫问题 public class MiGong{ public static void main(String[] args){ //先创建迷宫，用二维数组表示 int[][] map=new int[8][7]; \t//先规定map数组的元素值：0表示可以走 1表示障碍物 \tint[][] map = new int[8][7]; //设置障碍物 \tfor(int i = 0;i \u0026lt; 7;i++){ map[0][i] = 1; map[7][i] = 1; } for(int i = 0;i \u0026lt; 8;i++){ map[i][0] = 1; map[i][6] = 1; } //输出当前的地图 \tSystem.out.println(\u0026#34;===当前地图情况===\u0026#34;); for(int i = 0;i \u0026lt; map.length;i++){ for(int j = 0;j \u0026lt; map[i].length;j++){ System.out.println(map[i][j]+\u0026#34; \u0026#34;); } System.out.println(); } //使用findWay找路 \tT t1 = new T(); //下右上左 \tt1.findWay(map,1,1); System.out.println(\u0026#34;\\n===找路的情况如下===\u0026#34;); for(int i = 0;i \u0026lt; map.length;i++){ for(int j = 0;j \u0026lt; map[i].length;j++){ System.out.println(map[i][j]+\u0026#34; \u0026#34;); } System.out.println(); } } } class T{ /* findWay用来找出迷宫的路径 如果找到，就返回true，否则返回false map就是二维数组，即表示迷宫 i,j就是老鼠的位置，初始化的位置为(1,1) map数组的各个值的含义 0表示可以走 1表示障碍物 2表示可以走 3表示走过，但走不通是死路 当map[6][5]=2就说明找到通路，就可以结束，否则就继续找 找路策略 下-\u0026gt;右-\u0026gt;上-\u0026gt;左 */ public boolean findWay(int[][] map,int i,int j){ if(map[6][5] == 2){//说明已经找到 \treturn true; }else{ if(map[i][j] == 0){//当前这个位置0，说明表示可以走 \tmap[i][j] = 2; //使用找路策略，来确定该位置是否真的可以走通 \tif(findWay(map,i+1,j)){ return true; }else if(findWay(map,i,j+1)){ return true; }else if(findWay(map,i-1,j)){ return true; }else if(findWay(map,i,j-1)){ return true; }else{ map[i][j] = 3; return false; } }else{ return false; } } } } 汉诺塔 汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子， 在一根柱子上从下往上按照大小顺序摞着 64 片圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一 根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\npublic class HanoiTower{ public static void main(String[] args){ Tower tower = new Tower(); tower.move(64,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;); } } class Tower{ //num表示要移动的个数，a,b,c分别表示A塔，B塔，C塔 \tpublic void move(int num,char a,char b,char c){ //如果只有一个盘 num=1 \tif(num == 1){ System.out.println(a+\u0026#34;-\u0026gt;\u0026#34;+c); }else{ //如果有多个盘，可以看成两个，最下面的和上面的所有盘 \t//先移动上面所有的盘到b，借助c \tmove(num-1,a,c,b); //把最下面的这个盘，移动到c \tSystem.out.println(a+\u0026#34;-\u0026gt;\u0026#34;+c); //再把b塔的所有盘，移动到c，借助a \tmove(num-1,b,a,c); } } } ","permalink":"https://lyrace.github.io/post/java10/","summary":"【Java笔记】10 递归 猴子吃桃 有一堆桃子，猴子第一天吃了其中的一半，并再多吃了一个。以后每天猴子都吃其中的一半，然后再多吃一个。当到第10天时，想再吃时，发现只有一个桃子了。问：最初共多少个桃子？\npublic calss Recursion{ public static void main(String[] args){ T t1 = new T(); int day = 0; int peachNum = t1.peach(day); if(peachNum != -1){ System.out.println(\u0026#34;第\u0026#34;+day+\u0026#34;天有\u0026#34;+peachNum+\u0026#34;个桃子\u0026#34;); } } } class T{ /* 1.day=10时 有1个桃子 2.day=9时 有(day10+1)*2=4 3.day=8时 有(day9+1)*2=10 前一天的桃子=(后一天的桃子+1)*2 */ public int peach(int day){ if(day == 10){//第10天，只有1个桃  return 1; }else if(day \u0026gt;= 1\u0026amp;\u0026amp;day \u0026lt;= 9){ return (peach(day+1)+1)*2; }else{ System.out.println(\u0026#34;day在1-10\u0026#34;); return -1; } } } 迷宫问题 public class MiGong{ public static void main(String[] args){ //先创建迷宫，用二维数组表示 int[][] map=new int[8][7]; \t//先规定map数组的元素值：0表示可以走 1表示障碍物 \tint[][] map = new int[8][7]; //设置障碍物 \tfor(int i = 0;i \u0026lt; 7;i++){ map[0][i] = 1; map[7][i] = 1; } for(int i = 0;i \u0026lt; 8;i++){ map[i][0] = 1; map[i][6] = 1; } //输出当前的地图 \tSystem.","title":"【Java笔记】10 递归"},{"content":"【Java笔记】09 面向对象 一、类与对象  属性 成员属性=属性=field\t访问修饰符 属性类型 属性名； 访问修饰符：public protected 默认 private 属性不赋值有默认值，跟数组默认值相同 方法（成员方法） 当程序执行到方法时，开辟一个独立的栈空间； 执行完毕，或者到return语句时，返回； 返回到调用方法的语句，继续执行后面的代码 方法的定义： 访问修饰符 返回数据类型 方法名（形参列表..）{//方法体 语句； return 返回值； }  同一个类中的方法调用，直接调用即可，不需要创建对象\nclass A{ //同一个类中的方法调用，直接调用即可，不需要创建对象 \tpubilc void print(int n){ System.out.println(\u0026#34;输出\u0026#34;); } public void test(){ print(); } } 跨类中的方法调用：A类调用B类方法，需要通过对象名调用。即创建B类的对象，再调用方法\n二、方法重载 java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致 方法名：必须相同 形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求） 返回类型：无要求\n三、可变参数 java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法 可变参数的实参可以为0个或任意多个 可变参数的实参可以为数组 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 一个形参列表中最多只能出现一个可变参数\npublic class VarParameter{ public static void main(String[] args){ //求2个、3个、4个...参数的和 \tHspMethod m = new HspMethod(); System.out.println(m.sum(1,5,100)); System.out.println(m.sum(1,19)); } } class HspMethod{ //int...表示接受的是可变参数，类型是int，即可接收多个int（0-多） \t//使用可变参数时，可以当做数组来使用，即nums可以当做数组 \t//遍历nums求和即可 \tpublic int sum(int... nums){ int res = 0; for(int i =0;i \u0026lt; nums.length;i++){ res += nums[i]; } return res; } } 四、作用域 1.java中，主要的变量就是属性（成员变量）和局部变量 2.局部变量一般是指在成员方法中定义的变量 3.Java作用域分类 全局变量：即属性，作用域为整个类 局部变量：除了属性以外的其他变量，作用域为定义它的代码块中 4.属性可以不赋值，直接使用，因为有默认值，局部变量必须赋值后才能使用，没有默认值 5.作用域范围 全局变量/属性：可以被本类使用，或其他类使用（通过对象调用） 局部变量：只能在本类中对于的方法中使用 6.全局变量可以加修饰符，局部变量不能加修饰符\n五、构造方法/构造器 构造方法又叫构造器，是类的一种特殊的方法，主要作用是完成对新对象的初始化 方法名和类名相同 没有返回值 创建对象时，系统自动的调用该类的构造器完成对象的初始化 [修饰符] 方法名（形参列表）{ 方法体； } 1.构造器的修饰符可以默认，也可以时public protected private 2.构造器没有返回值 3.方法名和类名字必须一样 4.参数列表和成员方法规则一样 5.一个类可以定义多个不同的构造器，即构造器重载 6.定义了自己的构造器，默认构造器就覆盖了，除非显式定义一下\npublic class Constructor{ public static void main(String[] args){ //new一个对象时，直接通过构造器初始化 \tPerson p1 = new Person(\u0026#34;jack\u0026#34;,3); } } class Person{ String name; int age; public Person(String pName,int pAge){ name = pName; age = pAge; } } 六、this java虚拟机给每个对象分配this，代表当前对象 this 关键字可以用来访问本类的属性、方法、构造器 this 用于区分当前类的属性和局部变量 访问成员方法的语法：this.方法名(参数列表);\nclass T{ public void f1(){ System.out.println(\u0026#34;f1()\u0026#34;); } public void f2(){ System.out.println(\u0026#34;f2()\u0026#34;); //调用本类的f1 \t//第一种方法 \tf1(); //第二种方法 \tthis.f1(); } } 访问构造器语法：this(参数列表); 注意只能在构造器中使用(即只能在构造器中访问另外一个构造器, 必须放在第一 条语句)\nclass T{ public T(){ this(\u0026#34;jack\u0026#34;,20);//访问构造器语法：this(参数列表);必须放置第一条语句 \tSystem.out.println(\u0026#34;T()构造器\u0026#34;); } public T(String name,int age){ System.out.println(\u0026#34;T(String name,int age)构造器\u0026#34;); } } this 不能在类定义的外部使用，只能在类定义的方法中使用\n七、访问修饰符 公开 public 受保护 protected 对子类和同一包的类公开 默认 对同一个包的类公开 私有 private 不对外公开 只有默认和public可以修饰类\n八、封装 把抽象出的数据[属性]和对数据的操作[方法]封装在一起，数据被保护在内部，程序的其他部分只有通过被授权的操作[方法]，才能对数据进行操作。 步骤： 1.先对属性私有化，让外部不能直接修改属性 2.提供一个公共的set方法，用于对属性判断并赋值\npublic void setXxx(类型 参数名){ //验证 \t属性 = 参数名; } 3.提供一个公共的get方法，用于获取属性的值\npublic getXxx(){//权限判断 \treturn xx; }  有构造器时想使用set方法，在构造器中使用set  public Person(String name, int age, double salary) { // this.name = name; // this.age = age; // this.salary = salary;  setSalary(salary); setAge(age); setName(name); } 九、继承 多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类（基类，超类），在父类中定义这些相同的属性和方法，子类（派生类）通过extends声明继承父类 子类继承了所有的属性和方法，但私有属性和方法不能在子类直接访问，要通过父类公共的方法； 创建子类时，不管使用子类的哪个构造器，默认都会调用父类的无参构造器，如果父类没有提供无参构造器，则必须在子类的构造器中用super指定使用父类的哪个构造器，即在子类构造器中写super(对应参数列表)； super()使用时放在构造器的第一行，super只能在构造器中使用； super()和this()都只能放在第一行-\u0026gt;不能同时存在； java所有类都是Object类的子类，Object是所有类的基类； 父类构造器的调用不限于父类，而是一直往上追溯； java单继承，子类最多只能直接继承一个父类； 子类和父类之间要满足is-a关系；\npublic class Encap { public static void main(String[] args) { Son son = new Son(); //内存的布局  // 要按照查找关系来返回信息  // (1) 首先看子类是否有该属性  // (2) 如果子类有这个属性，并且可以访问，则返回信息  // (3) 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)  // (4) 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object...  System.out.println(son.name);//返回就是大头儿子  //System.out.println(son.age);//会报错，age是私有的属性  System.out.println(son.getAge());//返回的就是 39  System.out.println(son.hobby);//返回的就是旅游  } } class GrandPa {//爷类  String name = \u0026#34;大头爷爷\u0026#34;; String hobby = \u0026#34;旅游\u0026#34;; } class Father extends GrandPa {//父类  String name = \u0026#34;大头爸爸\u0026#34;; private int age = 39; public int getAge() { return age; } } class Son extends Father { //子类  String name = \u0026#34;大头儿子\u0026#34;; } 十、super关键字 访问父类的属性、方法、构造器： 1.访问属性（不能访问父类的private属性） super.属性名； 2.访问父类的方法，不能访问父类的private方法 super.方法名（参数列表）； 3.访问父类的构造器 super(参数列表)； 只能放在第一句 子类、父类方法有重名时，为了访问父类的成员，用super。没有重名，super，this，直接访问一样 找方法时，顺序： 1.先找本类，如果有，调用 2.如果没有，则找父类。父类如果有，并可以调用，则调用 3.如果父类没有，继续找父类的父类，知道Object 查找方法过程中，找到了但不能访问（比如private），报错\n十一、方法重写/覆盖 子类有一个方法和父类的某个方法的名称、返回类型、参数一样，子类的这个方法覆盖了父类的方法 返回类型父类的返回类型是子类的父类也可以。比如父类返回类型是Object，子类是String 子类方法不能缩小父类方法的访问权限\n 比较方法重载和重写     名称 发生范围 方法名 形参列表 返回类型 修饰符     重载 本类 必须一样 类型，个数或顺序至少有一个不同 无要求 无要求   重写 父子类 必须一样 相同 子类重写的方法，返回类型和父类的返回类型一直或者是其子类 子类方法不能缩小父类方法的访问范围    多态 问题：代码复用性不高 解决方案：多态\u0026ndash;\u0026gt;方法或对象有多种形态\n 方法的多态 方法重载、重写体现多态 对象的多态 （1）一个对象的编译类型和运行类型可以不一致 父类的引用指向子类的对象 Animal an = new Dog(); an的编译类型是Animal，运行类型是Dog （2）编译类型在定义对象时就确定了，不能改变 （3）运行类型时可以变化的 an = new Cat(); an的运行类型变成了Cat，编译类型仍然是Animal （4）编译类型看定义时=的左边，运行类型看=的右边  public class Poly{ //animal编译类型就是Animal，运行类型Dog \tAnimal animal = new Dog(); animal.cry(); //狗叫  //animal编译类型就是Animal，运行类型Cat \tanimal = new Cat(); animal.cry(); //猫叫 } 多态的前提时两个对象/类存在继承关系\n  向上转型 （1）本质：父类的引用指向了子类的对象 （2）语法：父类类型 引用名 = new 子类类型()； （3）可以调用父类中的所有成员（遵循访问权限），不能调用子类中的特有成员 编译阶段 调用哪些方法是编译类型决定的，比如animal想调用Cat类特有的catchMouse()方法编译报错 运行阶段 调用是先从子类开始的，遵循方法调用规则\n  向下转型 子类类型 引用名 = （子类类型）父类引用; Cat cat = (Cat) animal; cat.catchMouse(); 只能强转父类的引用，不能强转父类的对象 父类的引用必须指向的是当前目标类型的对象 Animal animal = new Cat(); //此时的animal指向的是Cat Cat cat = (Cat) animal; //这样才能向下转型成Cat 如果是转成Dog类 不对 向下转型后，可以调用子类类型中所有的成员\n  属性不重写，属性的值看编译类型\n  public class Poly01 { public static void main(String[] args) { //属性没有重写之说！属性的值看编译类型  Base base = new Sub();//向上转型  System.out.println(base.count);// ？ 看编译类型 10  Sub sub = new Sub(); System.out.println(sub.count);//? 20  } } class Base { //父类  int count = 10;//属性 } class Sub extends Base { //子类  int count = 20;//属性 } }  instanceOf 比较操作符，用于判断对象的运行类型是否为 XX 类型或 XX 类型的子类型 动态绑定机制 当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定 当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用  public class DynamicBinding { public static void main(String[] args) { //a 的编译类型 A, 运行类型 B  A a = new B();//向上转型  System.out.println(a.sum());//?40 -\u0026gt; 30  System.out.println(a.sum1());//?30-\u0026gt; 20  } } class A {//父类  public int i = 10; //动态绑定机制:  public int sum() {//父类sum()  return getI() + 10;//20 + 10  } public int sum1() {//父类sum1()  return i + 10;//10 + 10  } public int getI() {//父类getI  return i; } } class B extends A {//子类  public int i = 20; // public int sum() { // return i + 20; // }  public int getI() {//子类getI()  return i; } // public int sum1() { // return i + 10; // } }  多态数组 数组的定义类型为父类类型，里面保存的实际元素为子类类型  public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String say(){ return name + \u0026#39;\\t\u0026#39; + age; } } public class Student extends Person{ private double score; public Student(String name, int age, double score) { super(name, age); this.score = score; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } @Override public String say(){ return super.say() + \u0026#34;score=\u0026#34; + score; } public void study(){ System.out.println(getName()+\u0026#34;正在学习\u0026#34;); } } public class Teacher extends Person{ private double salary; public Teacher(String name, int age, double salary) { super(name, age); this.salary = salary; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } @Override public String say(){ return super.say()+\u0026#34;salary=\u0026#34;+salary; } public void teach(){ System.out.println(getName()+\u0026#34;正在讲课\u0026#34;); } } public class PolyArray { public static void main(String[] args) { Person[] persons = new Person[5]; persons[0] = new Person(\u0026#34;jack\u0026#34;,20); persons[1] = new Student(\u0026#34;jack\u0026#34;,18,100); persons[2] = new Student(\u0026#34;smith\u0026#34;,19,30.1); persons[3] = new Teacher(\u0026#34;s\u0026#34;,30,20000); persons[4] = new Teacher(\u0026#34;king\u0026#34;,50,25000); //循环遍历多态数组，调用say()  for(int i = 0;i \u0026lt; persons.length;i++){ System.out.println(persons[i].say());//动态绑定，编译类型是Person，运行类型根据实际情况  if(persons[i] instanceof Student){ //运行类型是不是Student  ((Student)persons[i]).study(); //向下转型  } else if(persons[i] instanceof Teacher){ Teacher teacher = (Teacher) persons[i]; teacher.teach(); } else if(persons[i] != null){ System.out.println(\u0026#34;\u0026#34;); }else{ System.out.println(\u0026#34;类型有误\u0026#34;); } } } }  多态参数 形参为父类类型，实参为子类类型  public class Employee { private String name; private double salary; public Employee(String name, double salary) { this.name = name; this.salary = salary; } public double getAnnual() { return 12.0D * this.salary; } public String getName() { return this.name; } public void setName(String name) { this.name = name; } public double getSalary() { return this.salary; } public void setSalary(double salary) { this.salary = salary; } } public class Manager extends Employee { private double bonus; public Manager(String name, double salary, double bonus) { super(name, salary); this.bonus = bonus; } public double getBonus() { return this.bonus; } public void setBonus(double bonus) { this.bonus = bonus; } public void manage() { System.out.println(\u0026#34;经理 \u0026#34; + this.getName() + \u0026#34; is managing\u0026#34;); } public double getAnnual() { return super.getAnnual() + this.bonus; } } public class Worker extends Employee { public Worker(String name, double salary) { super(name, salary); } public void work() { System.out.println(\u0026#34;普通员工 \u0026#34; + this.getName() + \u0026#34; is working\u0026#34;); } public double getAnnual() { return super.getAnnual(); } } public class PloyParameter { public PloyParameter() { } public static void main(String[] args) { Worker tom = new Worker(\u0026#34;tom\u0026#34;, 2500.0D); Manager milan = new Manager(\u0026#34;milan\u0026#34;, 5000.0D, 200000.0D); PloyParameter ployParameter = new PloyParameter(); ployParameter.showEmpAnnual(tom); ployParameter.showEmpAnnual(milan); ployParameter.testWork(tom); ployParameter.testWork(milan); } public void showEmpAnnual(Employee e) { System.out.println(e.getAnnual()); } public void testWork(Employee e) { if (e instanceof Worker) { ((Worker)e).work(); } else if (e instanceof Manager) { ((Manager)e).manage(); } else { System.out.println(\u0026#34;\u0026#34;); } } }   Object类\n是类层次结构的根类，每个类都使用Object作为超类，所有对象都实现这个类的方法。\n  equals方法\n==和equals的对比：\n==是一个比较运算符，既可以判断基本类型，也可以判断引用类型。基本类型：值是否相等，引用类型：判断地址是否相等。\nequals只能判断引用类型，默认判断地址是否相等，子类中往往重写该方法，判断内容是否相等，如String类型。\n//Object类的equals方法 public boolean equals(Object obj){ return (this == obj); // 比较对象地址是否相同 } //Integer类的equals方法 public boolean equals(Object obj){ if(obj instanceof Integer){ return value == ((Integer)obj).intValue(); } return false; } Integer i1 = new Integer(1000); Integer i1 = new Integer(1000); System.out.println(i1 == i2); // false System.out.println(i1.equals(i2)); //true   hashCode()\n提高具有哈希结构的容器的效率\n两个引用，指向同一个对象，哈希值一样\n两个引用，指向不同对象，哈希值不一样\n哈希值主要依据地址号，不能完全将哈希值等价于地址\npublic class HashCode_ { public static void main(String[] args) { A a = new A(); A a1 = new A(); A a2 = a; System.out.println(a.hashCode()); //1163157884  System.out.println(a1.hashCode()); //1956725890  System.out.println(a2.hashCode()); //1163157884  } } class A {}      toString()\n默认返回：全类名+@+哈希值的十六进制 子类往往重写toString方法，用于返回对象的属性信息\npublic class ToString_ { public static void main(String[] args) { /* Object的toSting() 源码 1. getClass().getName() 类的全类名(包名+类名) 2. Integer.toHexString(hashCode()) 将对象的hashCode值转成16进制字符串 public String toString() { return getClass().getName() + \u0026#34;@\u0026#34; + Integer.toHexString(hashCode()); } */ M m = new M(\u0026#34;小妖怪\u0026#34;, \u0026#34;巡山\u0026#34;, 1000); System.out.println(m.toString()+\u0026#34; hashCode=\u0026#34;+m.hashCode()); // object.M@4554617c hashCode=1163157884  } } class M{ private String name; private String job; private double sal; public M(String name, String job, double sal) { this.name = name; this.job = job; this.sal = sal; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getJob() { return job; } public void setJob(String job) { this.job = job; } public double getSal() { return sal; } public void setSal(double sal) { this.sal = sal; } } 重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式\n// 重写toString方法，输出对象的属性 // 使用快捷键即可 alt+insert -\u0026gt; toString @Override public String toString() { // 重写后，默认把对象的属性输出  return \u0026#34;M{\u0026#34; + \u0026#34;name=\u0026#39;\u0026#34; + name + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, job=\u0026#39;\u0026#34; + job + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, sal=\u0026#34; + sal + \u0026#39;}\u0026#39;; } M m = new M(\u0026#34;小妖怪\u0026#34;, \u0026#34;巡山\u0026#34;, 1000); System.out.println(m.toString()); // M{name=\u0026#39;小妖怪\u0026#39;, job=\u0026#39;巡山\u0026#39;, sal=1000.0} 直接输出一个对象时，toString方法会被默认的调用\nSystem.out.println(\u0026#34;当直接输出一个对象时，toString方法会被默认调用\u0026#34;); System.out.println(m); // 等价 m.toString() /* 当直接输出一个对象时，toString方法会被默认调用 M{name=\u0026#39;小妖怪\u0026#39;, job=\u0026#39;巡山\u0026#39;, sal=1000.0} */   finalize()\n当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，释放资源\n什么时候被回收：当某个对象没有任何引用时。jvm认为这个对象是一个垃圾对象，使用垃圾回收机制销毁该对象，销毁该对象前，先调用finalize方法\n垃圾回收机制的调用，是由系统决定，也可以通过System.gc()主动触发垃圾回收机制\npublic class Finalize_ { public static void main(String[] args) { Car c = new Car(\u0026#34;车\u0026#34;); // 这时，car对象就是一个垃圾，回收器会回收对象，在销毁对象前，会调用该对象的finalize方法  // 在finalize中，写自己的业务逻辑，比如释放资源：数据库连接，或打开文件..  // 如果不重写，就会调用Object类的finalize，即默认处理  c = null; System.gc();// 主动调用垃圾回收机制  System.out.println(\u0026#34;退出\u0026#34;); } } class Car { private String name; public Car(String name) { this.name = name; } // 重写finalize  @Override protected void finalize() throws Throwable { System.out.println(\u0026#34;销毁\u0026#34;); } }   ","permalink":"https://lyrace.github.io/post/java9/","summary":"【Java笔记】09 面向对象 一、类与对象  属性 成员属性=属性=field\t访问修饰符 属性类型 属性名； 访问修饰符：public protected 默认 private 属性不赋值有默认值，跟数组默认值相同 方法（成员方法） 当程序执行到方法时，开辟一个独立的栈空间； 执行完毕，或者到return语句时，返回； 返回到调用方法的语句，继续执行后面的代码 方法的定义： 访问修饰符 返回数据类型 方法名（形参列表..）{//方法体 语句； return 返回值； }  同一个类中的方法调用，直接调用即可，不需要创建对象\nclass A{ //同一个类中的方法调用，直接调用即可，不需要创建对象 \tpubilc void print(int n){ System.out.println(\u0026#34;输出\u0026#34;); } public void test(){ print(); } } 跨类中的方法调用：A类调用B类方法，需要通过对象名调用。即创建B类的对象，再调用方法\n二、方法重载 java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致 方法名：必须相同 形参列表：必须不同（形参类型或个数或顺序，至少有一样不同，参数名无要求） 返回类型：无要求\n三、可变参数 java允许将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法 可变参数的实参可以为0个或任意多个 可变参数的实参可以为数组 可变参数的本质就是数组 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后 一个形参列表中最多只能出现一个可变参数\npublic class VarParameter{ public static void main(String[] args){ //求2个、3个、4个...参数的和 \tHspMethod m = new HspMethod(); System.","title":"【Java笔记】09 面向对象"},{"content":"【Java笔记】08数组 一、介绍 数组存放多个同一类型的数据，是引用类型\n 数组的定义 数据类型[] 数组名 = new 数据类型[大小] int[] a = new int[5];  先声明，再创建 声明：数据类型 数组名[]；或 数据类型[] 数组名；此时为null 创建：数组名=new 数据类型[大小];\n静态初始化 数据类型 数组名[]={元素值，元素值,\u0026hellip;}\n 注意 1.数组创建后，如果没有赋值，有默认值 int 0,short 0,byte 0,long 0 ,float 0.0,double 0.0,char \\u0000,boolean false，String null 2.数组属引用类型，数组型数据是对象（object）  二、数组赋值机制 数组在默认情况下是引用传递，赋的值是地址——\u0026gt;赋值方式为引用传递\n//arr2变化会影响到arr1 \tint[] arr1 = {1,2,3}; int[] arr2 = arr1; arr2[0] = 10; //arr1={10,2,3} 三、应用 排序  内部排序：所有数据加载到内存 外部排序：借助外部存储   冒泡排序 通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素 的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部  //数组[24,69,80,57,13] //第一轮 最大数放最后 24,69,80,57,13-\u0026gt;24,69,80,57,13-\u0026gt;24,69,57,80,13-\u0026gt;24,69,57,13,80  //第二轮 第二大的数放在倒数第二位置 24,69,57,13,80-\u0026gt;24 57 69 13 80-\u0026gt;24 57 13 69 80  //第三轮 第三大的数放在倒数第三位置 24 57 13 69 80-\u0026gt;24 13 57 69 80  //第四轮 第四大的数放在倒数第四位置 13 24 57 69 80 public class BubbleSort { public static void main(String []args) { int[] arr = {24,69,80,57,13}; int temp = 0; for(int i=0;i\u0026lt;arr.length-1;i++){ for(int j = 0;j \u0026lt; arr.length-1-i;j++){ if(arr[j] \u0026gt; arr[j + 1]){ temp = arr[j]; arr[j] = arr[j + 1]; arr[j+1] = temp; } } System.out.println(\u0026#34;\\n==第\u0026#34;+(i+1)+\u0026#34;轮==\u0026#34;); for(int j=0;j \u0026lt; arr.length;j++){ System.out.print(arr[j]+\u0026#34;\\t\u0026#34;); } } } } 查找 顺序查找\nimport java.util.Scanner; //顺序查找 public class SeqSearch { public static void main(String []args) { /*有一个数列：白眉鹰王、金毛狮王、紫衫龙王、青翼蝠王猜数游戏： 从键盘中任意输入一个名称，判断数列中是否包含此名称【顺序查找】 要求: 如果找到了，就提示找到，并给出下标值 */ String[] names = {\u0026#34;白眉鹰王\u0026#34;,\u0026#34;金毛狮王\u0026#34;,\u0026#34;紫衫龙王\u0026#34;,\u0026#34;青翼蝠王\u0026#34;}; Scanner myScanner = new Scanner(System.in); System.out.println(\u0026#34;请输入名字\u0026#34;); String findName = myScanner.next(); int index = -1; for(int i = 0; i \u0026lt; names.length; i++) { //比较 字符串比较 equals, 如果要找到名字就是当前元素 \tif(findName.equals(names[i])) { System.out.println(\u0026#34;恭喜你找到 \u0026#34; + findName); System.out.println(\u0026#34;下标为= \u0026#34; + i); //把 i 保存到 index \tindex = i; break;//退出 \t} } if(index == -1) { //没有找到 \tSystem.out.println(\u0026#34;sorry ,没有找到 \u0026#34; + findName); } } } 四、多维数组 列数不确定初始化\npublic class MyClass { public static void main(String args[]) { int[][] arr = new int[3][]; for(int i=0;i \u0026lt; arr.length;i++){ arr[i] = new int[i+1]; for(int j = 0;j \u0026lt; arr[i].length;j++){ arr[i][j] = i+1; } } for (int i = 0;i\u0026lt;arr.length;i++){ for(int j=0;j\u0026lt;arr[i].length;j++){ System.out.print(arr[i][j]+\u0026#34; \u0026#34;); } System.out.println(); } } }    String[] str = new String[]{\u0026ldquo;a\u0026rdquo;,\u0026ldquo;b\u0026rdquo;,\u0026ldquo;c\u0026rdquo;};//ok\n  int[] str = new int[]{1,2,3};//ok\n  public class Insert{ public static void main(String[] args){ /* 已知有个升序的数组，要求插入一个元素，该数组顺序依然是升序的 [10,12,45,90]-\u0026gt;[10,12,23,45,90] 数组扩容+定位 */ int[] arr = {10,12,23,45,90}; int insertNum = 23; int index = -1;//将要插入的位置 \t//遍历arr，if insertNum\u0026lt;=arr[i],i就是插入位 \t//if 遍历完没有 insertNum\u0026lt;=arr[i]，index=arr.length \tfor(int i=0;i\u0026lt;arr.length;i++){ if(insertNum \u0026lt;= arr[i]){ index = i; break; } } if(index == -1){ index = arr.length; } int arrNew = new int[arr.length+1]; for(int i=0,j=0;i\u0026lt;arrNew.length;i++){ if(i != index){ arrNew[i] = arr[j]; j++; }else{ arrNew[i] = insertNum; } } arr = arrNew; for(int i = 0;i\u0026lt;arr.length;i++) System.out.println(arr[i]); } } ","permalink":"https://lyrace.github.io/post/java8/","summary":"【Java笔记】08数组 一、介绍 数组存放多个同一类型的数据，是引用类型\n 数组的定义 数据类型[] 数组名 = new 数据类型[大小] int[] a = new int[5];  先声明，再创建 声明：数据类型 数组名[]；或 数据类型[] 数组名；此时为null 创建：数组名=new 数据类型[大小];\n静态初始化 数据类型 数组名[]={元素值，元素值,\u0026hellip;}\n 注意 1.数组创建后，如果没有赋值，有默认值 int 0,short 0,byte 0,long 0 ,float 0.0,double 0.0,char \\u0000,boolean false，String null 2.数组属引用类型，数组型数据是对象（object）  二、数组赋值机制 数组在默认情况下是引用传递，赋的值是地址——\u0026gt;赋值方式为引用传递\n//arr2变化会影响到arr1 \tint[] arr1 = {1,2,3}; int[] arr2 = arr1; arr2[0] = 10; //arr1={10,2,3} 三、应用 排序  内部排序：所有数据加载到内存 外部排序：借助外部存储   冒泡排序 通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素 的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部  //数组[24,69,80,57,13] //第一轮 最大数放最后 24,69,80,57,13-\u0026gt;24,69,80,57,13-\u0026gt;24,69,57,80,13-\u0026gt;24,69,57,13,80  //第二轮 第二大的数放在倒数第二位置 24,69,57,13,80-\u0026gt;24 57 69 13 80-\u0026gt;24 57 13 69 80  //第三轮 第三大的数放在倒数第三位置 24 57 13 69 80-\u0026gt;24 13 57 69 80  //第四轮 第四大的数放在倒数第四位置 13 24 57 69 80 public class BubbleSort { public static void main(String []args) { int[] arr = {24,69,80,57,13}; int temp = 0; for(int i=0;i\u0026lt;arr.","title":"【Java笔记】08数组"},{"content":"【Java笔记】07 控制结构 三大流程控制语句：顺序控制、分支控制、循环控制\n分支控制 switch 表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型 switch（表达式）中表达式的返回值必须是byte,short,int,char,enum,String case子句中的值必须是常量，而不能是变量、\n//3，4，5月春季，6，7，8月夏季，9，10，11秋季，12，1，2月冬季 \tScanner myScanner = new Scanner(System.in); System.out.println(\u0026#34;输入月份\u0026#34;); int m = myScanner.nextInt(); switch(m){ case 3: case 4: case 5: System.out.println(\u0026#34;春季\u0026#34;); break; case 6: case 7: case 8: System.out.println(\u0026#34;夏季\u0026#34;); break; case 9: case 10: case 11: System.out.println(\u0026#34;秋季\u0026#34;); break; case 12: case 1: case 2: System.out.println(\u0026#34;冬季\u0026#34;); break; default: System.out.println(\u0026#34;输入的月份不对\u0026#34;); } break break语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块 continue语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块\nlabel1: for(int j=0;j\u0026lt;4;j++){ label2: for(int i=0;i\u0026lt;10;i++){ if(i == 2){ break lable1; } System.out.println(\u0026#34;i=\u0026#34;+i); } } ","permalink":"https://lyrace.github.io/post/java7/","summary":"【Java笔记】07 控制结构 三大流程控制语句：顺序控制、分支控制、循环控制\n分支控制 switch 表达式数据类型，应和case后的常量类型一致，或者是可以自动转成可以相互比较的类型 switch（表达式）中表达式的返回值必须是byte,short,int,char,enum,String case子句中的值必须是常量，而不能是变量、\n//3，4，5月春季，6，7，8月夏季，9，10，11秋季，12，1，2月冬季 \tScanner myScanner = new Scanner(System.in); System.out.println(\u0026#34;输入月份\u0026#34;); int m = myScanner.nextInt(); switch(m){ case 3: case 4: case 5: System.out.println(\u0026#34;春季\u0026#34;); break; case 6: case 7: case 8: System.out.println(\u0026#34;夏季\u0026#34;); break; case 9: case 10: case 11: System.out.println(\u0026#34;秋季\u0026#34;); break; case 12: case 1: case 2: System.out.println(\u0026#34;冬季\u0026#34;); break; default: System.out.println(\u0026#34;输入的月份不对\u0026#34;); } break break语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块 continue语句出现在多层嵌套的语句块中，可以通过标签指明要终止的是哪一层语句块\nlabel1: for(int j=0;j\u0026lt;4;j++){ label2: for(int i=0;i\u0026lt;10;i++){ if(i == 2){ break lable1; } System.","title":"【Java笔记】07 控制结构"},{"content":"【Java笔记】06 进制 一、四种进制 整数的四种表示方法： 1.二进制：0，1，满2进1，以0b或0B开头 2.十进制：0-9，满10进1 3.八进制：0-7，满8进1，以数字0开头表示 4.十六进制：0-15，满16进1，以0x或0X开头表示\nint n1 = 0b1010;//二进制，10 \tint n2 = 1010;//十进制，1010 \tint n3 = 01010;//八进制，01010 \tint n4 = 0X10101//十六进制，0X10101 二、进制转换  十进制转二进制 除2取余，注意一个字节8位 34=0B0010 0010 十进制转八进制 除8取余，131=0203 十进制转十六进制 除16取余，237=0xED 二进制转八进制 低位开始，二进制数三位一组，转成八进制 0B11 010 101=\u0026gt;0 3 2 5 二进制转十六进制 低位开始，四位一组 0b1101 0101 =\u0026gt; 0x D 5  三、原码、反码、补码 对于有符号： 1.二进制的最高位是符号位，0表示整数，1表示负数 2.正数的原码、反码、补码都一样 3.负数的反码=原码符号位不变，其它位取反 4.负数的补码=反码+1，负数的反码=负数的补码-1 5.0的反码，补码都是0 6.Java没有无符号数 7.计算机都是以补码的方式运算的 8.看运算结果时，看原码\n四、位运算符  按位与\u0026amp;\t两位全为1，结果为1，否则为0 2\u0026amp;3 1.2的原码=\u0026gt;00000000 00000000 00000000 00000010 2的补码=\u0026gt;00000000 00000000 00000000 00000010 2.3的补码=\u0026gt;00000000 00000000 00000000 00000011 3.按位与\u0026amp; 00000000 00000000 00000000 00000010 00000000 00000000 00000000 00000011 =\u0026gt;00000000 00000000 00000000 00000010 运算后的补码 原码一样 结果是2 按位或|\t两位一个为1，结果为1，否则为0 按位异或^\t两位一个为0，一个为1（两位不一样），结果为1，否则为0 按位取反~\t0-\u0026gt;1,1-\u0026gt;0 算数右移\u0026raquo;：低位溢出，符号位不变，符号位补溢出的高位 int a = 1 \u0026raquo; 2;//1 =\u0026gt; 00000001 =\u0026gt;00000000\t本质1÷2÷2=0 算数左移\u0026laquo;：符号位不变，低位补0 int a = 1 \u0026laquo; 2;//1 =\u0026gt; 00000001 =\u0026gt; 00000100\t本质1×2×2 逻辑右移、无符号右移\u0026raquo;\u0026gt;：低位溢出，高位补0  ","permalink":"https://lyrace.github.io/post/java6/","summary":"【Java笔记】06 进制 一、四种进制 整数的四种表示方法： 1.二进制：0，1，满2进1，以0b或0B开头 2.十进制：0-9，满10进1 3.八进制：0-7，满8进1，以数字0开头表示 4.十六进制：0-15，满16进1，以0x或0X开头表示\nint n1 = 0b1010;//二进制，10 \tint n2 = 1010;//十进制，1010 \tint n3 = 01010;//八进制，01010 \tint n4 = 0X10101//十六进制，0X10101 二、进制转换  十进制转二进制 除2取余，注意一个字节8位 34=0B0010 0010 十进制转八进制 除8取余，131=0203 十进制转十六进制 除16取余，237=0xED 二进制转八进制 低位开始，二进制数三位一组，转成八进制 0B11 010 101=\u0026gt;0 3 2 5 二进制转十六进制 低位开始，四位一组 0b1101 0101 =\u0026gt; 0x D 5  三、原码、反码、补码 对于有符号： 1.二进制的最高位是符号位，0表示整数，1表示负数 2.正数的原码、反码、补码都一样 3.负数的反码=原码符号位不变，其它位取反 4.负数的补码=反码+1，负数的反码=负数的补码-1 5.0的反码，补码都是0 6.Java没有无符号数 7.计算机都是以补码的方式运算的 8.看运算结果时，看原码\n四、位运算符  按位与\u0026amp;\t两位全为1，结果为1，否则为0 2\u0026amp;3 1.2的原码=\u0026gt;00000000 00000000 00000000 00000010 2的补码=\u0026gt;00000000 00000000 00000000 00000010 2.","title":"【Java笔记】06 进制"},{"content":"【Java笔记】05 键盘输入 键盘输入语句 扫描器 Scanner\tjava.util.* 1.导入该类所在的包 2.创建Scanner对象\nimport java.util.Scanner; public class Input{ public static void main(String[] args){ Scanner myScanner = new Scanner(System.in); //执行到next方法时，会等待用户输入 \tString name = myScanner.next();//接收用户输入字符串 \tint age = myScanner.nextInt(); double sal = myScanner.nextDouble(); } } ","permalink":"https://lyrace.github.io/post/java5/","summary":"【Java笔记】05 键盘输入 键盘输入语句 扫描器 Scanner\tjava.util.* 1.导入该类所在的包 2.创建Scanner对象\nimport java.util.Scanner; public class Input{ public static void main(String[] args){ Scanner myScanner = new Scanner(System.in); //执行到next方法时，会等待用户输入 \tString name = myScanner.next();//接收用户输入字符串 \tint age = myScanner.nextInt(); double sal = myScanner.nextDouble(); } } ","title":"【Java笔记】05 键盘输入"},{"content":"【Java笔记】04 运算符 一、算数运算符 运算符：+（正号）、-（负号）、+、-、*、/、%、++、\u0026ndash;、 +（字符串相加） 1./\nSystem.out.println(10 / 4); //2 \tSystem.out.println(10.0 / 4); //2.5 \tdouble d = 10 / 4;//2.0 2.% 取模，取余 %运算， a % b = a - a / b * b 10%3=1\t//10-10/33=1 -10%3=-1\t//(-10)-(-10)/33=-1 10%-3=1\t//10-10/(-3)(-3)=1 %运算，a是小数的情况下， a % b = a - (int)a / b * b -10.5%3 = -10.5 - (-10)/33 = -10.5+9=-1.5 3.++\n 作为独立语句 i++;//自增，等价于 i=i+1； ++i;//自增，等价于i=i+1; 作为表达式使用 前++：++i先自增，后赋值 后++：i++先赋值，后自增  int i = 8; int k = ++i;//i=i+1;k=i; \tSystem.out.println(\u0026#34;k=\u0026#34; + k + \u0026#34;i=\u0026#34; + i); //9 9 \tint j = 8; int l = j++;//k=j;j=j+1; \tSystem.out.println(\u0026#34;j=\u0026#34; + j + \u0026#34;l=\u0026#34; +l);\t//8 9 int i = 1;//i-\u0026gt;1 \ti = i++;//规定 使用临时变量：（1）temp=i;(2)i=i+1;(3)i=temp; \tSystem.out.println(i); // 1 int i = 1;//i-\u0026gt;1 \ti = ++i;//规定 使用临时变量：(1)i=i+1;（2）temp=i;(3)i=temp; \tSystem.out.println(i); // 2 二、关系运算符（比较运算符） 结果都是boolean，即true或false 关系运算符组成的表达式，称为关系表达式 boolean = a \u0026gt; b; 1.==\t相等 2.!=\t不等 3.\u0026lt; 4.\u0026gt; 5.\u0026lt;= 6.\u0026gt;= 7.instance of\t检查是否是类的对象 示例：pandas 是基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。\n三、逻辑运算符  a\u0026amp;b : \u0026amp; 叫逻辑与：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false a\u0026amp;\u0026amp;b : \u0026amp;\u0026amp; 叫短路与：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false    \u0026amp;和\u0026amp;\u0026amp;的区别 1.\u0026amp;\u0026amp;短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false，效率高 2.\u0026amp;逻辑与：不管第一个条件是否为false，第二个条件都要判断，效率低  int a = 4; int b = 9; //对\u0026amp;\u0026amp;，如果第一个条件为false，后面的条件不再判断，即++b不执行 \tif(a \u0026lt; 1 \u0026amp;\u0026amp; ++b \u0026lt; 50){ System.out.println(\u0026#34;ok\u0026#34;); } System.out.println(\u0026#34;a=\u0026#34; + a + \u0026#34;b=\u0026#34; + b); //4 9 \t//对\u0026amp;，如果第一个条件为false，后面的条件判断，即++b执行 \tif(a \u0026lt; 1 \u0026amp; ++b \u0026lt; 50){ System.out.println(\u0026#34;ok\u0026#34;); } System.out.println(\u0026#34;a=\u0026#34; + a + \u0026#34;b=\u0026#34; + b); //4 10  a|b : | 叫逻辑或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false a||b : || 叫短路或，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false    |和||的区别 1.||短路或：如果第一个条件为true，后面条件不判断，最终结果为true 2.|逻辑或：如果第一个条件为true，后面条件判断，最终结果为true   !a : 叫取反，或者非运算。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true a^b: 叫逻辑异或，当 a 和 b 不同时，则结果为 true, 否则为 false  int x = 5; int y = 5; //x++ == 6,后++,先比较后自增，比较5==6，false；x自增=6; \t//++y == 6,先++，先自增后比较，y自增=6；比较6=6，true; \tif(x++ == 6 \u0026amp; ++y == 6){ x=11; } System.out.println(x,y); // 6 6 四、赋值运算符 1.基本赋值运算符= 2.复合赋值运算符 +=，-=，/=，%= 复合赋值运算符会进行类型转换\nbyte b = 3; b += 2;\t//等价于 b = (byte)(b + 2); 五、三元运算符 条件表达式？表达式1：表达式2； 表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换）\n六、运算符优先级     . () {} ; ,     R-\u0026gt;L ++ \u0026ndash;\t~ !   L-\u0026gt;R * / + -   L-\u0026gt;R + -   L-\u0026gt;R \u0026laquo; \u0026raquo; \u0026raquo;\u0026gt; 位移   L-\u0026gt;R \u0026lt; \u0026gt; \u0026lt;= \u0026gt;= instanceof   L-\u0026gt;R == !=   L-\u0026gt;R \u0026amp;   L-\u0026gt;R ^   L-\u0026gt;R |   L-\u0026gt;R \u0026amp;\u0026amp;   L-\u0026gt;R ||   L-\u0026gt;R ? :   R-\u0026gt;L = *= /= %=    += -= \u0026laquo;= \u0026raquo;=    \u0026raquo;\u0026gt;= \u0026amp;= ^= |=   从上到下优先级降低     ","permalink":"https://lyrace.github.io/post/java4/","summary":"【Java笔记】04 运算符 一、算数运算符 运算符：+（正号）、-（负号）、+、-、*、/、%、++、\u0026ndash;、 +（字符串相加） 1./\nSystem.out.println(10 / 4); //2 \tSystem.out.println(10.0 / 4); //2.5 \tdouble d = 10 / 4;//2.0 2.% 取模，取余 %运算， a % b = a - a / b * b 10%3=1\t//10-10/33=1 -10%3=-1\t//(-10)-(-10)/33=-1 10%-3=1\t//10-10/(-3)(-3)=1 %运算，a是小数的情况下， a % b = a - (int)a / b * b -10.5%3 = -10.5 - (-10)/33 = -10.5+9=-1.5 3.++\n 作为独立语句 i++;//自增，等价于 i=i+1； ++i;//自增，等价于i=i+1; 作为表达式使用 前++：++i先自增，后赋值 后++：i++先赋值，后自增  int i = 8; int k = ++i;//i=i+1;k=i; \tSystem.","title":"【Java笔记】04 运算符"},{"content":"【Java笔记】03 变量 一、变量基本  概念  变量是程序的基本组成单位，相当于内存中一个数据存储空间的表示，基本要素（类型、名称、值）\n 步骤   声明变量 int a; 赋值 a=60; 使用 System.out.println(a);   注意事项 1.变量表示内存中的一个存储区域 2.该区域有名称和内存 3.先声明后使用 4.该区域的数据在同一类型范围内变化 5.变量在同一作用域不能重名  二、+的使用 1.左右都是数值型=\u0026gt;加法运算 2.左右两边有一方为字符串=\u0026gt;拼接运算\nSystem.out.println(100+98);//198 System.out.println(\u0026#34;100\u0026#34;+98);//10098 System.out.println(100+3+\u0026#34;hello\u0026#34;);//103hello System.out.println(\u0026#34;hello\u0026#34;+100+3);//hello1003 三、数据类型 1.基本数据类型\n 数值型 整数类型，存放整数 byte(字节)[1],short[2],int[4],long[8] 浮点类型 float[4],double[8] 字符型 存放单个字符 char[2] 布尔型 存放true,false boolean[1] 2.引用数据类型 类 接口 数组  四、整数类型    类型 占用存储空间 范围     byte,字节 1字节 -128~127   short,短整型 2字节 -2^15^ ~ 2^15^-1，-32768~32767   int,整型 4字节 -2^31^ ~ 2^31^-1，-2147483648~2147483647   long,长整型 8字节 -2^63^ ~ 2^63^-1      坑  double num1 = 2.7; double num2 = 8.1/3; System.out.println(num1); //2.7 \tSystem.out.println(num2); //接近2.7的一个小数，而不是2.7 对运算结果是小数的进行相等判断时，Pay Attention! 正确写法：\nif(Math.abs(num1 - num2) \u0026lt; 0.000001) { //差值非常小，达到要求精度 \tSystem.out.println(\u0026#34;相等\u0026#34;); } 但直接赋值时，两数可判断相等。\n六、字符类型 字符类型可以直接存放一个数字 char c=97;\n1.字符常量单引号 2.允许用转义字符 char c = \u0026lsquo;\\t\u0026rsquo;; 3.Java中，char的本质是一个整数，在输出时，对应unicode码对应的字符 4.char类型是可以进行运算的，相当于一个整数\nSystem.out.println(\u0026#39;a\u0026#39; + 10);//107 \tchar c5 = \u0026#39;b\u0026#39; + 1;//98+1==\u0026gt; 99 \tSystem.out.println((int)c5); //99 \tSystem.out.println(c5); //99-\u0026gt;ASCII码=\u0026gt;c  字符类型本质 字符存储到计算机中，将对应的码值找出来 存储：\u0026lsquo;a\u0026rsquo;=\u0026gt;码值 97=\u0026gt;二进制 110 0001=\u0026gt;存储 读取：二进制 110 0001=\u0026gt;97=\u0026gt;\u0026lsquo;a\u0026rsquo;=\u0026gt;显示 编码表 ASCII 一个字节表示，128个字符。实际上一个字节可以表示256个字符，只用了128个 Unicode 固定大小的编码，使用两个字节来表示字符，字母和汉字都是占用两个字节，浪费空间 utf-8 大小可变的编码，字母使用1个字节，汉字使用3个字节 gbk 可表示汉字，范围更广泛，字母使用1个字节，汉字使用2个字节 gb2312 可以表示汉字，少用 big5 繁体汉字  七、布尔类型 占1个字节，适用于逻辑运算 只允许取值true和false 不能用0或非0代替false和true\n八、数据类型转换  自动类型转换 1.精度小的类型自动转换为精度大的数据类型 char -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double byte -\u0026gt; short -\u0026gt;int -\u0026gt; long -\u0026gt; float -\u0026gt;double 2.有多种类型的数据混合运算时，系统首先将所有数据转换成容量最大的那种数据类型，再进行计算  public class Convert{ public static void main (String[] args){ int n1 = 10; //float d1 = n1 + 1.1;//错误 n1+1.1结果是double类型 \tdouble d1 = n1 + 1.1;//✔ \tfloat d = n1 + 1.1F;//✔ \t} } 3.byte和short不能跟char进行自动类型转换 当把数赋给byte时，先判断该数是否在byte范围内\nbyte b1 = 10;//✔ -128~127 \tbyte b = 1000;//✘\t超出范围 \tint n2 = 1; byte b2 = n2;//✘ 变量赋值，会判断类型 \tchar c1 = b1;//✘ 4.byte,short,char可以进行运算，都转成int\nbyte b2 = 1; byte b3 = 2; short s1 = 1; short s2 = b2 + s1;//✘\tbyte和short运算时转成int，再赋值给小精度的short类型报错 \tbyte b4 = b2 + b3;//✘\tbyte和byte运算时转成int 5.boolean类型不参与自动类型转换\n 强制类型转换 自动类型转换的逆过程，容量大的数据类型转换为容量小的，可能造成精度降低或溢出 e.g.:int i = (int)1.9; 强转符号只对最近的操作数有效  int x = (int)10*3.5+6*1.5;//编译错误：只强转了10，结果是double-\u0026gt;int \tint y = (int)(10*3.5+6*1.5);//(int)44.0-\u0026gt;44 char类型可以保存int的常量值，但不能保存int的变量值，需要强转\nchar c1 = 100;//right \tint m = 100; char c2 = m;//错误 \tchar c3 = (char)m;//right\t100对应的字符 d  基本数据类型和String类型的转换   基本类型转String 加 \u0026quot; \u0026quot;  int n1 = 100; float f1 = 1.1F; double d1 = 4.5; boolean b1 = true; String s1 = n1 + \u0026#34;\u0026#34;; String s2 = f1 + \u0026#34;\u0026#34;; String s3 = d1 + \u0026#34;\u0026#34;; String s4 = b1 + \u0026#34;\u0026#34;; String类型转基本数据类型 基本类型的包装类调用parseXX方法即可  String s5 = \u0026#34;123\u0026#34;; int num = Integer.parseInt(s5); double num1 = Double.parseDouble(s5); float num2 = Float.parseFloat(s5); long num3 = Long.parseLong(s5); byte num4 = Byte.parseByte(s5); boolean b = Boolean.parseBoolean(\u0026#34;true\u0026#34;); short num5 = Short.parseShort(s5); //字符串-\u0026gt;字符，取字符串第一个字符 \tSystem.out.println(s5.charAt(0));//1 ","permalink":"https://lyrace.github.io/post/java3/","summary":"【Java笔记】03 变量 一、变量基本  概念  变量是程序的基本组成单位，相当于内存中一个数据存储空间的表示，基本要素（类型、名称、值）\n 步骤   声明变量 int a; 赋值 a=60; 使用 System.out.println(a);   注意事项 1.变量表示内存中的一个存储区域 2.该区域有名称和内存 3.先声明后使用 4.该区域的数据在同一类型范围内变化 5.变量在同一作用域不能重名  二、+的使用 1.左右都是数值型=\u0026gt;加法运算 2.左右两边有一方为字符串=\u0026gt;拼接运算\nSystem.out.println(100+98);//198 System.out.println(\u0026#34;100\u0026#34;+98);//10098 System.out.println(100+3+\u0026#34;hello\u0026#34;);//103hello System.out.println(\u0026#34;hello\u0026#34;+100+3);//hello1003 三、数据类型 1.基本数据类型\n 数值型 整数类型，存放整数 byte(字节)[1],short[2],int[4],long[8] 浮点类型 float[4],double[8] 字符型 存放单个字符 char[2] 布尔型 存放true,false boolean[1] 2.引用数据类型 类 接口 数组  四、整数类型    类型 占用存储空间 范围     byte,字节 1字节 -128~127   short,短整型 2字节 -2^15^ ~ 2^15^-1，-32768~32767   int,整型 4字节 -2^31^ ~ 2^31^-1，-2147483648~2147483647   long,长整型 8字节 -2^63^ ~ 2^63^-1      坑  double num1 = 2.","title":"【Java笔记】03 变量"},{"content":"【Java笔记】02 DOS 一、DOS命令 Dos：Disk Operating System磁盘操作系统\n二、路径 相对路径：从当前目录开始定位形成的一个路径\t..-\u0026gt;上一层 绝对路径：从顶级目录开始定位形成的一个路径\n三、常用的Dos命令 1.查看当前目录有什么内容 dir 路径 2.切换到其他盘 切换到c盘 cd \\D c: 3.切换到当前盘的其他目录下、 cd d:\\abc\\test cd ....\\abc\\test 4.切换到上一级 cd .. 5.切换到根目录 cd 6.查看指定的目录下所有的子级目录 tree 7.清屏 cls 8.推出Dos exit 9.md[创建目录]，rd[删除目录]，copy[拷贝文件]，del[删除文件]，echo[输入内容到文件，echo hello \u0026gt; ok.txt],move[剪切/移动]\n","permalink":"https://lyrace.github.io/post/java2/","summary":"【Java笔记】02 DOS 一、DOS命令 Dos：Disk Operating System磁盘操作系统\n二、路径 相对路径：从当前目录开始定位形成的一个路径\t..-\u0026gt;上一层 绝对路径：从顶级目录开始定位形成的一个路径\n三、常用的Dos命令 1.查看当前目录有什么内容 dir 路径 2.切换到其他盘 切换到c盘 cd \\D c: 3.切换到当前盘的其他目录下、 cd d:\\abc\\test cd ....\\abc\\test 4.切换到上一级 cd .. 5.切换到根目录 cd 6.查看指定的目录下所有的子级目录 tree 7.清屏 cls 8.推出Dos exit 9.md[创建目录]，rd[删除目录]，copy[拷贝文件]，del[删除文件]，echo[输入内容到文件，echo hello \u0026gt; ok.txt],move[剪切/移动]","title":"【Java笔记】02 DOS"},{"content":"【Java笔记】01 概述 一、java特性 1.面向对象的（oop) 2.健壮的，由强制类型机制、异常处理、垃圾的自动收集等保证 3.跨平台性的，一个编译好的class文件可在多个操作系统下运行 4.解释性的 解释性：编译后的代码，不能直接被机器执行，需要解释器来执行,javascript,PHP,java 编译性：编译后的代码，可以直接被机器执行，c/c++\n二、java运行机制及运行过程 JVM让同一个java程序在三个不同的操作系统中都可以执行——\u0026gt;跨平台性 1.java核心机制——java虚拟机[JVM java virtual machine]\n 基本介绍 1.JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK中 2.不同的平台有不同的虚拟机 3.虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行  JDK \u0026amp; JRE 1.JDK 全称Java Development Kit，java开发工具包 JDK=JRE+java的开发工具java，javac，javadoc,javap等 2.JRE Java Runtime Environment，java运行环境 JRE=JVM+Java的核心类库 =\u0026gt;JDK=JVM+Java SE标准类库+开发工具集  三、Java开发注意事项 一个源文件最多只能有一个public类。其它类的个数不限。编译后每一个类都对应一个.class 也可以将main方法写在非public类中，然后指定运行非public类这样入口方法就是非public的main方法\npublic class Hello{ public static void main (String []args){ System.out.println(\u0026#34;Hello,l\u0026#34;); } } public class Hello{ public static void main (String []args){ System.out.println(\u0026#34;Hello,l\u0026#34;); } } class Dog{ public static void main (String []args){ System.out.println(\u0026#34;Hello,d\u0026#34;); } } class Cat{ public static void main (String []args){ System.out.println(\u0026#34;Hello,c\u0026#34;); } } 四、Java转义字符 \\t：一个制表位 \\n：换行符 \\：一个\n\u0026quot;：一个\u0026quot; '：一个' \\r：一个回车，光标移到行首，\\r后面的替换\\r前部分字符\n 回车和换行在命令行和IDEA中实测有区别  五、注释 1.单行注释 //注释文字 ctrl+/同时注释多行 2.多行注释 /注释文字/ 多行注释不能嵌套多行注释 3.文档注释 注释内容可以被jdk提供的工具javadoc所解析，生成一套以网页形式体现的该程序的说明文档，一般写在类 javadoc标签\n//文档注释  /** * @author ace * @version 1.0 */ public class Test { public static void main(String[] args) { System.out.println(\u0026#34;abcde\\rmn\u0026#34;); System.out.println(\u0026#34;------------\u0026#34;); System.out.println(\u0026#34;abcde\\r\\nmn\u0026#34;); } } javadoc -d 文件夹名 -xx -yy 类名.java e.g.:javadoc -d C:\\Users\\ace\\Desktop\\comment -author -version Test.java 六、Java API文档 java8 中文文档 https://www.matools.com/api/java8 七、标识符 不能以数字开头 由26个英文大小写，0-9，_或$组成 包名：多单词组成时所有字母都小写 类名、接口名：多单词组成时，所有单词的首字母大写 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写 常量名：所有字母都大写，多单词时每个单词用下划线连接\n","permalink":"https://lyrace.github.io/post/java1/","summary":"【Java笔记】01 概述 一、java特性 1.面向对象的（oop) 2.健壮的，由强制类型机制、异常处理、垃圾的自动收集等保证 3.跨平台性的，一个编译好的class文件可在多个操作系统下运行 4.解释性的 解释性：编译后的代码，不能直接被机器执行，需要解释器来执行,javascript,PHP,java 编译性：编译后的代码，可以直接被机器执行，c/c++\n二、java运行机制及运行过程 JVM让同一个java程序在三个不同的操作系统中都可以执行——\u0026gt;跨平台性 1.java核心机制——java虚拟机[JVM java virtual machine]\n 基本介绍 1.JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器，包含在JDK中 2.不同的平台有不同的虚拟机 3.虚拟机机制屏蔽了底层运行平台的差别，实现了一次编译，到处运行  JDK \u0026amp; JRE 1.JDK 全称Java Development Kit，java开发工具包 JDK=JRE+java的开发工具java，javac，javadoc,javap等 2.JRE Java Runtime Environment，java运行环境 JRE=JVM+Java的核心类库 =\u0026gt;JDK=JVM+Java SE标准类库+开发工具集  三、Java开发注意事项 一个源文件最多只能有一个public类。其它类的个数不限。编译后每一个类都对应一个.class 也可以将main方法写在非public类中，然后指定运行非public类这样入口方法就是非public的main方法\npublic class Hello{ public static void main (String []args){ System.out.println(\u0026#34;Hello,l\u0026#34;); } } public class Hello{ public static void main (String []args){ System.out.println(\u0026#34;Hello,l\u0026#34;); } } class Dog{ public static void main (String []args){ System.","title":"【Java笔记】01 概述"}]